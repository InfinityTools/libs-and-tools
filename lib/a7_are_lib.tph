///////////////////////////////////////////////////////////////////////////////////////////////////
// A library for patching ARE resources
//
// Author:  Argent77
// License: MIT
//
// Copyright 2026 Argent77
//
// Permission is hereby granted, free of charge, to any person obtaining 
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////////////////////

OUTER_SPRINT A7_ARE_LIB_VERSION ~1.0~

// *** Standalone functions ***
// Action function that creates an empty ARE file.
// DEFINE_ACTION_FUNCTION a7#are_create


// *** Open/close functions for batch processing ***
// Patch function that opens the current ARE file and returns an ARE handle for further editing.
// IMPORTANT: Only after calling "a7#are_open" batch functions can be used to modify ARE content.
// DEFINE_PATCH_FUNCTION a7#are_open

// Patch function that writes all modifications made by batch functions back to the ARE file.
// DEFINE_PATCH_FUNCTION a7#are_close


// *** Query functions ***
// Action and patch function that returns general information about the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_info

// Action and patch function that returns actor information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_actor

// Action and patch function that returns region information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_region

// Action and patch function that returns spawn point information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_spawnpoint

// Action and patch function that returns entrance information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_entrance

// Action and patch function that returns container information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_container

// Action and patch function that returns container item information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_container_item

// Action and patch function that returns ambient sound information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_ambient

// Action and patch function that returns variable information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_variable

// Action and patch function that returns explored bitmap data from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_explored

// Action and patch function that returns door information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_door

// Action and patch function that returns animation information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_animation

// Action and patch function that returns songs information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_songs

// Action and patch function that returns rest encounter information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_rest

// Action and patch function that returns automap note information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_automap

// Action and patch function that returns projectile trap information from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_projectile


// *** Patch functions ***
// Action and patch function that alters basic area attributes on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_attributes

// Action and patch function that adds a new actor to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_actor

// Action and patch function that alters attributes of an existing actor structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_actor

// Action and patch function that removes an existing actor structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_actor

// Action and patch function that moves the position or changes the orientation of an actor on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_actor

// Action and patch function that adds a new region to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_region

// Action and patch function that alters attributes of an existing region structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_region

// Action and patch function that removes an existing region structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_region

// Action and patch function that moves the position of a region on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_region

// Action and patch function that scales a region polygon on the ARE handle by a specified factor in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_scale_region

// Action and patch function that adds a new spawn point to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_spawnpoint

// Action and patch function that alters attributes of an existing spawn point structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_spawnpoint

// Action and patch function that removes an existing spawn point structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_spawnpoint

// Action and patch function that moves the position of a spawn point on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_spawnpoint

// Action and patch function that adds a new entrance to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_entrance

// Action and patch function that alters attributes of an existing entrance structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_entrance

// Action and patch function that removes an existing entrance structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_entrance

// Action and patch function that moves the position of an entrance on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_entrance

// Action and patch function that adds a new container to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_container

// Action and patch function that alters attributes of an existing container structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_container

// Action and patch function that removes an existing container structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_container

// Action and patch function that moves the position of a container on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_container

// Action and patch function that scales a container polygon on the ARE handle by a specified factor in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_scale_container

// Action and patch function that adds a new item to a container in the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_container_item

// Action and patch function that alters attributes of an existing container item structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_container_item

// Action and patch function that removes an existing container item structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_container_item

// Action and patch function that adds a new ambient sound to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_ambient

// Action and patch function that alters attributes of an existing ambient sound structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_ambient

// Action and patch function that removes an existing ambient sound structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_ambient

// Action and patch function that moves the position of a ambient sound on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_ambient

// Action and patch function that adds a new variable to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_variable

// Action and patch function that alters attributes of an existing variable structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_variable

// Action and patch function that removes an existing variable structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_variable

// Action and patch function that sets the explored bitmap in the ARE handle to specified string data.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_set_explored

// Action and patch function that clears the whole explored bitmap buffer from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_clear_explored

// Action and patch function that alters the explored bitmap to the "explored" or "unexplored" state in the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_explored

// Action and patch function that adds a new door to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_door

// Action and patch function that alters attributes of an existing door structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_door

// Action and patch function that removes an existing door structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_door

// Action and patch function that moves the position of a door on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_door

// Action and patch function that scales a door polygon on the ARE handle by a specified factor in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_scale_door

// Action and patch function that adds a new animation to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_animation

// Action and patch function that alters attributes of an existing animation structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_animation

// Action and patch function that removes an existing animation structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_animation

// Action and patch function that moves the position of a animation on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_animation

// Action and patch function that alters attributes of the songs structure on an ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_songs

// Action and patch function that alters attributes of the rest encounters structure on an ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_rest

// Action and patch function that adds a new automap note to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_automap

// Action and patch function that alters attributes of an existing automap note structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_automap

// Action and patch function that removes an existing automap note structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_automap

// Action and patch function that moves the position of a automap note on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_automap

// Action and patch function that adds a new projectile trap to the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_projectile

// Action and patch function that alters attributes of an existing projectile trap structure on the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_projectile

// Action and patch function that removes an existing projectile trap structure from the ARE handle.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_projectile

// Action and patch function that moves the position of a projectile trap on the ARE handle by a specified amount in either direction.
// DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_projectile

/*
ARE structure "are"
  - version: "V1.0" or "V9.1" (ARE format version)
  - wed_resref: WED resref
  - last_saved: last saved (real time)
  - area_flags: area flags (see AREAFLAG.IDS)
  - area_resref_north: ARE resref
  - area_flags_north: area flags
  - area_resref_east: ARE resref
  - area_flags_east: area flags
  - area_resref_south: ARE resref
  - area_flags_south: area flags
  - area_resref_west: ARE resref
  - flags_west: area flags
  - area_type: area type flags (see AREATYPE.IDS)
  - probability_rain:
  - probability_snow:
  - probability_fog:
  - probability_lightning:
  - overlay_transparency: wind speed (unused) or overlay transparency (EE only)
  - area_difficulty_2: avg. party level requirement for area difficulty level 2 (V9.1 only)
  - area_difficulty_3: avg. party level requirement for area difficulty level 3 (V9.1 only)
  - area_difficulty_1: avg. party level requirement (V9.1 only)
  - area_script: BCS resref
  - rest_movie_day: MVE/WBM resref
  - rest_movie_night: MVE/WBM resref

  - actor: # actor structures
    - <idx>: raw actor buffer
      - name: actor name
      - cre_attached: boolean that indicates whether a CRE resource is attached
      - cre: raw CRE buffer if "cre_attached" != 0, empty string otherwise
  - region: # region structures
    - <idx>: raw region buffer
      - name: region name
      - vertex: # vertex structures
        - <idx>: combined (x,y) coordinates; as "x | (y << 16)" for ease of access
  - spawnpoint: # spawn point structures
    - <idx>: raw spawn point buffer
      - name: spawn point name
  - entrance: # entrance structures
    - <idx>: raw entrance buffer
      - name: entrance name
  - container: # container structures
    - <idx>: raw container buffer
      - name: container name
      - item: # item structures
        - <idx>: raw item structure
          - resref: ITM resref
      - vertex: # vertex structures (added after tile objects structures)
        - <idx>: combined (x,y) coordinates; as "x | (y << 16)" for ease of access
  - ambient: # ambient sound structures
    - <idx>: raw ambient sound buffer
      - name: ambient sound name
  - variable: # variable structures
    - <idx>: raw variable buffer
      - name: variable name
      - value: integer value
  - explored: raw "explored cells" buffer
  - door: # door structures
    - <idx>: raw door buffer
      - name: door name
      - vertex_open: # open door vertex structures
        - <idx>: combined (x,y) coordinates; as "x | (y << 16)" for ease of access
      - vertex_closed: # closed door vertex structures
        - <idx>: combined (x,y) coordinates; as "x | (y << 16)" for ease of access
      - cell_open: # open door impeded cells
        - <idx>: combined (x,y) cell coordinates; as "x | (y << 16)" for ease of access
      - cell_closed: # closed door impeded cells
        - <idx>: combined (x,y) cell coordinates; as "x | (y << 16)" for ease of access
  - animation: # animation structures
    - <idx>: raw animation buffer
      - name: animation name
  - tiled: # tiled object structures (unused)
    - <idx>: raw tiled object buffer
      - name: tiled object name
      - cell_open: # open state search cells
        - <idx>: combined (x,y) cell coordinates; as "x | (y << 16)" for ease of access
      - cell_closed: # closed state search cells
        - <idx>: combined (x,y) cell coordinates; as "x | (y << 16)" for ease of access
  - songs:raw songs data block
  - rest: raw rest encounters data block
  - automap: # automap notes structures
    - <idx>: raw automap note buffer
      - is_tlk: boolean that indicates whether "text" refers to a dialog.tlk string (all games except PST)
      - text: strref of the note text (all games except PST), literal text of the note (PST)
  - projectile: # projectile traps structures (V1.0 only)
    - <idx>: raw projectile buffer
      - effect: # EFF V2 effects
        - <idx>: raw EFF V2 buffer

Order of structures:
  - CRE (attached to Actors)
  - Actors
  - Regions
  - Spawn Points
  - Entrances
  - Containers
  - Items
  - Ambient Sounds
  - Variables
  - Doors
  - Cells for Tiled Objects
  - Tiled Objects
  - Vertices/Impeded cells
  - Animations
  - Explored Bitmap
  - Songs
  - Rest Encounters
  - Automap Notes
  - Effects (for Projectile Traps)
  - Projectile Traps (offset=0 if no structures defined)
*/


/**
 * Valid for array items in alter_* functions:
 * Assign this "magic" value to vertex_* definitions that shouldn't be altered.
 */
OUTER_SET A7_ARE_NO_CHANGE = 0x7ffe7ffe


/**
 * Action function that creates an empty ARE file.
 *
 * INT_VAR preset         Specify 1 to populate the "Songs" and "Rest Encounters" structures with sane default values. (Default: 0)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR resref         Resource reference of the resulting ARE file. Length must not exceed 8 characters.
 * STR_VAR path           Destination folder for ARE file. (Default: "override")
 * STR_VAR version        ARE version to create. Supported versions are "V1.0" and "V9.1". (Default: autodetected)
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_ACTION_FUNCTION a7#are_create
INT_VAR
  preset = 0
  silent = 0
STR_VAR
  resref = ~~
  path = ~override~
  version = ~~
RET
  success
BEGIN
  OUTER_SET success = 1

  ACTION_IF (~%resref%~ STR_EQ ~~) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: No resref specified.~
    END
  END ELSE ACTION_IF (STRING_LENGTH ~%resref%~ > 8) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: resref name is too long.~
    END
  END

  ACTION_IF (~%path%~ STR_EQ ~~) BEGIN
    // failsafe path definition to prevent file creation in the system's root folder
    OUTER_SPRINT path ~.~
  END

  ACTION_IF (~%version%~ STR_EQ ~~) BEGIN
    ACTION_IF (GAME_IS ~iwd2~) BEGIN
      OUTER_SPRINT version ~V9.1~
    END ELSE BEGIN
      OUTER_SPRINT version ~V1.0~
    END
  END
  ACTION_TO_UPPER ~version~

  ACTION_IF (NOT (~%version%~ STR_EQ ~V1.0~ || ~%version%~ STR_EQ ~V9.1~)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Unsupported ARE version: %version%~
    END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
<<<<<<<< .../inlined/a7_are_lib/blank
>>>>>>>>
    OUTER_SET is_v1 = ~%version%~ STR_EQ ~V1.0~
    COPY ~.../inlined/a7_are_lib/blank~ ~%path%/%resref%.are~
      SET adjust = is_v1 ? 0 : 0x10
      SET size_are = 656 + adjust

      DELETE_BYTES 0 BUFFER_LENGTH
      INSERT_BYTES 0 size_are

      WRITE_ASCIIE 0x00 ~AREA%version%~ (8)

      SET start_ofs = 0x11c + adjust
      PATCH_FOR_EACH offset IN 0x54 0x5c 0x60 0x68 0x70 0x78 0x7c 0x84 0x88 0xa0 0xa8 0xb0 0xb8 0xbc BEGIN
        WRITE_LONG (offset + adjust) start_ofs
      END

      PATCH_IF (preset) BEGIN
        // filling Songs structure with sane defaults
        FOR (i = 0; i < 10; ++i) BEGIN
          WRITE_LONG (start_ofs + i * 4) "-1" // song id
        END
        WRITE_LONG (start_ofs + 0x38) 100 // ambient sound (day)
        WRITE_LONG (start_ofs + 0x4c) 100 // ambient sound (night)
      END

      // rest encounters
      SET start_ofs += 0x90
      WRITE_LONG (0xc0 + adjust) start_ofs

      PATCH_IF (preset) BEGIN
        // filling Rest Encounters with sane defaults
        SET strref = 10134  // Default message if rest is interrupted
        FOR (i = 0; i < 10; ++i) BEGIN
          WRITE_LONG (start_ofs + i * 4) strref
        END
        WRITE_SHORT (start_ofs + 0x9a) 1
        WRITE_LONG (start_ofs + 0x9c) 1
        WRITE_SHORT (start_ofs + 0xa0) 1
        WRITE_SHORT (start_ofs + 0xa2) 1
        WRITE_SHORT (start_ofs + 0xa4) 10
        WRITE_SHORT (start_ofs + 0xa6) 1
        WRITE_SHORT (start_ofs + 0xa8) 10
        WRITE_SHORT (start_ofs + 0xaa) 10
      END

      // automap notes
      SET start_ofs += 0xe4
      WRITE_LONG (0xc4 + adjust) start_ofs
  END
END


/**
 * Patch function that opens the current ARE file and returns an ARE handle for further editing.
 *
 * IMPORTANT: Only after calling "a7#are_open" batch functions can be used to modify ARE content.
 *
 * RET success            Returns 1 on success and 0 on error.
 * RET_ARRAY are          Returns a handle of the initialized ARE structure if "success" returns 1.
 *                        The name of this handle must be specified as parameter for the "a7#batch_xxx" functions.
 */
DEFINE_PATCH_FUNCTION a7#are_open
RET
  success
RET_ARRAY
  are
BEGIN
  LPF a7#__are_disassemble RET success RET_ARRAY are END
END

/**
 * Patch function that writes all modifications made by batch functions back to the ARE file.
 *
 * STR_VAR are            Name of the ARE array structure. (Default: "are")
 * RET success            Returns 1 on success and 0 on error.
 */
DEFINE_PATCH_FUNCTION a7#are_close
STR_VAR
  are = ~are~
RET
  success
BEGIN
  LPF a7#__are_assemble STR_VAR are RET success END
END


/**
 * Action and patch function that returns general information about the ARE handle.
 *
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET version            Returns the version string of the ARE handle.
 * RET num_actors         Returns the number of available actor structures.
 * RET num_regions        Returns the number of available region structures.
 * RET num_spawnpoints    Returns the number of available spawn point structures.
 * RET num_entrances      Returns the number of available entrance structures.
 * RET num_containers     Returns the number of available container structures.
 * RET num_ambients       Returns the number of available ambient sound structures.
 * RET num_variables      Returns the number of available variable structures.
 * RET num_doors          Returns the number of available door structures.
 * RET num_animations     Returns the number of available animation structures.
 * RET num_tile           Returns the number of available tiled object structures.
 * RET num_automaps       Returns the number of available automap note structures.
 * RET num_projectiles    Returns the number of available projectile trap structures.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_info
STR_VAR
  are = ~are~
RET
  success
  version
  num_actors
  num_regions
  num_spawnpoints
  num_entrances
  num_containers
  num_ambients
  num_variables
  num_doors
  num_animations
  num_tile
  num_automaps
  num_projectiles
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SPRINT version ~~
  OUTER_SET num_actors = "-1"
  OUTER_SET num_regions = "-1"
  OUTER_SET num_spawnpoints = "-1"
  OUTER_SET num_entrances = "-1"
  OUTER_SET num_containers = "-1"
  OUTER_SET num_ambients = "-1"
  OUTER_SET num_variables = "-1"
  OUTER_SET num_doors = "-1"
  OUTER_SET num_animations = "-1"
  OUTER_SET num_tile = "-1"
  OUTER_SET num_automaps = "-1"
  OUTER_SET num_projectiles = "-1"

  ACTION_IF (success) BEGIN
    OUTER_SPRINT version $~%are%~(~version~)
    OUTER_SET num_actors = $~%are%~(~actor~)
    OUTER_SET num_regions = $~%are%~(~region~)
    OUTER_SET num_spawnpoints = $~%are%~(~spawnpoint~)
    OUTER_SET num_entrances = $~%are%~(~entrance~)
    OUTER_SET num_containers = $~%are%~(~container~)
    OUTER_SET num_ambients = $~%are%~(~ambient~)
    OUTER_SET num_variables = $~%are%~(~variable~)
    OUTER_SET num_doors = $~%are%~(~door~)
    OUTER_SET num_animations = $~%are%~(~animation~)
    OUTER_SET num_tile = $~%are%~(~tiled~)
    OUTER_SET num_automaps = $~%are%~(~automap~)
    OUTER_SET num_projectiles = $~%are%~(~projectile~)
  END
END

/**
 * Action and patch function that returns actor information from the ARE handle.
 *
 * INT_VAR index          Index of the actor structure to query information about. Omit if you specify the actor structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the actor structure to query. Omit if you specify the actor structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY actor        Returns an associative array with information about the specified actor structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_actor" function,
 *                        e.g. $actor("loc_x").
 *                        Exceptions:
 *                        - $actor("cre_embedded") Returns the CRE data buffer as string if available.
 *                        - $actor("cre_name_alt"): Returns the alternate actor name for embedded CRE resources (V1.0 only).
 *                        Note: Some fields are version-specific.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_actor
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  actor
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~actor~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~actor~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $actor(~name~) (32) NULL
      READ_SSHORT 0x20 $actor(~loc_x~)
      READ_SSHORT 0x22 $actor(~loc_y~)
      READ_SSHORT 0x24 $actor(~dest_x~)
      READ_SSHORT 0x26 $actor(~dest_y~)
      READ_LONG 0x28 $actor(~flags~)
      READ_SHORT 0x2c $actor(~is_spawned~)
      PATCH_IF (NOT is_v1) BEGIN
        READ_BYTE 0x2f $actor(~area_difficulty~)
      END
      READ_LONG 0x30 $actor(~animation~)
      READ_SHORT 0x34 $actor(~orientation~)
      READ_SLONG 0x38 $actor(~expiry~)
      READ_SHORT 0x3c $actor(~wander_distance~)
      READ_SHORT 0x3e $actor(~follow_distance~)
      READ_LONG 0x40 $actor(~schedule~)
      READ_LONG 0x44 $actor(~num_times_talked_to~)
      READ_ASCII 0x48 $actor(~dlg_resref~) (8) NULL
      READ_ASCII 0x50 $actor(~bcs_override~) (8) NULL
      PATCH_IF (is_v1) BEGIN
        READ_ASCII 0x58 $actor(~bcs_general~) (8) NULL
        READ_ASCII 0x60 $actor(~bcs_class~) (8) NULL
        READ_ASCII 0x68 $actor(~bcs_race~) (8) NULL
        READ_ASCII 0x70 $actor(~bcs_default~) (8) NULL
        READ_ASCII 0x78 $actor(~bcs_specific~) (8) NULL
        READ_ASCII 0x90 $actor(~cre_name_alt~) (32) NULL
      END ELSE BEGIN
        READ_ASCII 0x58 $actor(~bcs_special3~) (8) NULL
        READ_ASCII 0x60 $actor(~bcs_special2~) (8) NULL
        READ_ASCII 0x68 $actor(~bcs_combat~) (8) NULL
        READ_ASCII 0x70 $actor(~bcs_movement~) (8) NULL
        READ_ASCII 0x78 $actor(~bcs_team~) (8) NULL
        READ_ASCII 0x90 $actor(~bcs_special1~) (8) NULL
      END
      READ_ASCII 0x80 $actor(~cre_resref~) (8) NULL
      SPRINT $actor(~cre_embedded~) $~%are%~(~actor~ ~%index%~ ~cre~)
    END
  END
END

/**
 * Action and patch function that returns region information from the ARE handle.
 *
 * INT_VAR index          Index of the region structure to query information about. Omit if you specify the region structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the region structure to query. Omit if you specify the region structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY region       Returns an associative array with information about the specified region structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_region" function,
 *                        e.g. $region("type"). Field names for the bounding box are named "min_x", "max_x", ...
 *                        Region vertices are stored as combined X/Y coordinates in $region("vertex" "<idx>").
 *                        $region("vertex") contains the number of vertex entries.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_region
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  region
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~region~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~region~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $region(~name~) (32) NULL
      READ_SHORT 0x20 $region(~type~)
      READ_SSHORT 0x22 $region(~min_x~)
      READ_SSHORT 0x24 $region(~min_y~)
      READ_SSHORT 0x26 $region(~max_x~)
      READ_SSHORT 0x28 $region(~max_y~)
      READ_SHORT 0x2a $region(~num_vertices~)
      READ_LONG 0x34 $region(~cursor_idx~)
      READ_ASCII 0x38 $region(~destination_area~) (8) NULL
      READ_ASCII 0x40 $region(~destination_name~) (32) NULL
      READ_LONG 0x60 $region(~flags~)
      READ_SLONG 0x64 $region(~info_point_strref~)
      READ_SHORT 0x68 $region(~trap_detect~)
      READ_SHORT 0x6a $region(~trap_remove~)
      READ_SHORT 0x6c $region(~trap_active~)
      READ_SHORT 0x6e $region(~trap_status~)
      READ_SSHORT 0x70 $region(~loc_x~)
      READ_SSHORT 0x72 $region(~loc_y~)
      READ_ASCII 0x74 $region(~key_resref~) (8) NULL
      READ_ASCII 0x7c $region(~script_resref~) (8) NULL
      READ_SSHORT 0x84 $region(~alt_x~)
      READ_SSHORT 0x86 $region(~alt_y~)
      PATCH_IF (is_v1 && (is_pst || is_pstee)) BEGIN
        READ_ASCII 0xac $region(~sound_resref~) (8) NULL
        READ_SSHORT 0xb4 $region(~talk_loc_x~)
        READ_SSHORT 0xb6 $region(~talk_loc_y~)
        READ_SLONG 0xb8 $region(~speaker_strref~)
        READ_ASCII 0xbc $region(~dialog_resref~) (8) NULL
      END ELSE PATCH_IF (NOT is_v1) BEGIN
        READ_SLONG 0x88 $region(~alt2_x~)
        READ_SLONG 0x8c $region(~alt2_y~)
      END
    END

    // storing vertex list
    OUTER_SET num_vertices = $~%are%~(~region~ ~%index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET $region(~vertex~ ~%idx%~) = $~%are%~(~region~ ~%index%~ ~vertex~ ~%idx%~)
    END
    OUTER_SET $region(~vertex~) = num_vertices
  END
END

/**
 * Action and patch function that returns spawn point information from the ARE handle.
 *
 * INT_VAR index          Index of the spawn point structure to query information about. Omit if you specify the spawn point structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the spawn point structure to query. Omit if you specify the spawn point structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY spawnpoint   Returns an associative array with information about the specified spawn point structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_spawnpoint" function,
 *                        e.g. $spawnpoint("loc_x").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_spawnpoint
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  spawnpoint
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~spawnpoint~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~spawnpoint~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $spawnpoint(~name~) (32) NULL
      READ_SSHORT 0x20 $spawnpoint(~loc_x~)
      READ_SSHORT 0x22 $spawnpoint(~loc_y~)
      FOR (i = 0; i < 10; ++i) BEGIN
        READ_ASCII (0x24 + i * 8) $spawnpoint(~cre_resref%i%~) (8) NULL
      END
      READ_SHORT 0x74 $spawnpoint(~spawn_num~)
      READ_SHORT 0x76 $spawnpoint(~difficulty~)
      READ_SHORT 0x78 $spawnpoint(~delay~)
      READ_SHORT 0x7a $spawnpoint(~method~)
      READ_LONG 0x7c $spawnpoint(~duration~)
      READ_SHORT 0x80 $spawnpoint(~wander_distance~)
      READ_SHORT 0x82 $spawnpoint(~follow_distance~)
      READ_SHORT 0x84 $spawnpoint(~max_num~)
      READ_SHORT 0x86 $spawnpoint(~active~)
      READ_LONG 0x88 $spawnpoint(~schedule~)
      READ_SHORT 0x8c $spawnpoint(~day_prob~)
      READ_SHORT 0x8e $spawnpoint(~night_prob~)
      PATCH_IF (is_v1 && is_ee) BEGIN
        READ_LONG 0x90 $spawnpoint(~spawn_freq~)
        READ_LONG 0x94 $spawnpoint(~countdown~)
        FOR (i = 0; i < 10; ++i) BEGIN
          READ_BYTE (0x98 + i) $spawnpoint(~weight%i%~)
        END
      END
    END
  END
END

/**
 * Action and patch function that returns entrance information from the ARE handle.
 *
 * INT_VAR index          Index of the entrance structure to query information about. Omit if you specify the entrance structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the entrance structure to query. Omit if you specify the entrance structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY entrance     Returns an associative array with information about the specified entrance structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_entrance" function,
 *                        e.g. $entrance("loc_x").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_entrance
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  entrance
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~entrance~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~entrance~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $entrance(~name~) (32) NULL
      READ_SSHORT 0x20 $entrance(~loc_x~)
      READ_SSHORT 0x22 $entrance(~loc_y~)
      READ_SHORT 0x24 $entrance(~orientation~)
    END
  END
END

/**
 * Action and patch function that returns container information from the ARE handle.
 *
 * INT_VAR index          Index of the container structure to query information about. Omit if you specify the container structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the container structure to query. Omit if you specify the container structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY container    Returns an associative array with information about the specified container structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_container" function,
 *                        e.g. $container("loc_x"). Field names for the bounding box are named "min_x", "max_x", ...
 *                        Container items are stored in $container("item" "<idx>") entries. They provide the same fields as item arrays returned
 *                        by "a7#batch_are_get_container_item". $container("item") contains the number of item entries.
 *                        Container vertices are stored as combined X/Y coordinates in $container("vertex" "<idx>").
 *                        $container("vertex") contains the number of vertex entries.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_container
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  container
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~container~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~container~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $container(~name~) (32) NULL
      READ_SSHORT 0x20 $container(~loc_x~)
      READ_SSHORT 0x22 $container(~loc_y~)
      READ_SHORT 0x24 $container(~type~)
      READ_SHORT 0x26 $container(~lock_diff~)
      READ_LONG 0x28 $container(~flags~)
      READ_SHORT 0x2c $container(~trap_detect~)
      READ_SHORT 0x2e $container(~trap_remove_diff~)
      READ_SHORT 0x30 $container(~trap_active~)
      READ_SHORT 0x32 $container(~trap_status~)
      READ_SSHORT 0x34 $container(~trap_loc_x~)
      READ_SSHORT 0x36 $container(~trap_loc_y~)
      READ_SSHORT 0x38 $container(~min_x~)
      READ_SSHORT 0x3a $container(~min_y~)
      READ_SSHORT 0x3c $container(~max_x~)
      READ_SSHORT 0x3e $container(~max_y~)
      READ_LONG 0x44 $container(~num_items~)
      READ_ASCII 0x48 $container(~trap_script~) (8) NULL
      READ_SHORT 0x54 $container(~num_vertices~)
      READ_SHORT 0x56 $container(~trigger_range~)
      READ_ASCII 0x58 $container(~owner_name~) (32) NULL
      READ_ASCII 0x78 $container(~key_resref~) (8) NULL
      READ_LONG 0x80 $container(~break_difficulty~)
      READ_SLONG 0x84 $container(~lockpick_strref~)
    END

    // storing item list
    OUTER_SET num_items = $~%are%~(~container~ ~%index%~ ~item~)
    OUTER_FOR (idx = 0; idx < num_items; ++idx) BEGIN
      LAF a7#batch_are_get_container_item
        INT_VAR
          container_index = index
          index = idx
          silent
        STR_VAR are
        RET success
        RET_ARRAY item
        // RET_ARRAY $container(~item~ ~%idx%~) = item  // doesn't work (yet)
      END
      // manually adding item, field-by-field
      ACTION_IF (success) BEGIN
        ACTION_PHP_EACH item AS key => value BEGIN
          OUTER_SPRINT $container(~item~ ~%idx%~ ~%key%~) ~%value%~
        END
      END
    END
    OUTER_SET $container(~item~) = num_items

    // storing vertex list
    OUTER_SET num_vertices = $~%are%~(~container~ ~%index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET $container(~vertex~ ~%idx%~) = $~%are%~(~container~ ~%index%~ ~vertex~ ~%idx%~)
    END
    OUTER_SET $container(~vertex~) = num_vertices
  END
END

/**
 * Action and patch function that returns container item information from the ARE handle.
 *
 * INT_VAR container_index  Index of the container structure. Omit if you specify the container structure by name.
 * INT_VAR index            Index of the container item structure to query information about. (Default: -1)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR container_name   Name of the container structure. Omit if you specify the container structure by index.
 * RET success              Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY item           Returns an associative array with information about the specified container item structure.
 *                          Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_container_item" function,
 *                          e.g. $item("item_resref").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_container_item
INT_VAR
  container_index = "-1"
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
RET
  success
RET_ARRAY
  item
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_items = $~%are%~(~container~ ~%container_index%~ ~item~)
    ACTION_IF (index < 0 || index >= num_items) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Index of "item" is out of bounds: %index%~
      END
    END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~ ~item~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $item(~item_resref~) (8) NULL
      READ_SSHORT 0x08 $item(~expiry~)
      READ_SHORT 0x0a $item(~charge1~)
      READ_SHORT 0x0c $item(~charge2~)
      READ_SHORT 0x0e $item(~charge3~)
      READ_LONG 0x10 $item(~flags~)
    END
  END
END

/**
 * Action and patch function that returns ambient sound information from the ARE handle.
 *
 * INT_VAR index          Index of the ambient sound structure to query information about. Omit if you specify the ambient sound structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the ambient sound structure to query. Omit if you specify the ambient sound structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY ambient      Returns an associative array with information about the specified ambient sound structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_ambient" function,
 *                        e.g. $ambient("loc_x").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_ambient
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  ambient
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~ambient~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~ambient~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $ambient(~name~) (32) NULL
      READ_SSHORT 0x20 $ambient(~loc_x~)
      READ_SSHORT 0x22 $ambient(~loc_y~)
      READ_SHORT 0x24 $ambient(~radius~)
      READ_SSHORT 0x26 $ambient(~loc_z~)
      READ_SLONG 0x28 $ambient(~pitch_variance~)
      READ_SSHORT 0x2c $ambient(~volume_variance~)
      READ_SHORT 0x2e $ambient(~volume~)
      FOR (i = 0; i < 10; ++i) BEGIN
        READ_ASCII (0x30 + i * 8) $ambient(~wav_resref%i%~) (8) NULL
      END
      READ_SHORT 0x80 $ambient(~sound_num~)
      READ_LONG 0x84 $ambient(~delay~)
      READ_SLONG 0x88 $ambient(~variation~)
      READ_LONG 0x8c $ambient(~schedule~)
      READ_LONG 0x90 $ambient(~flags~)
    END
  END
END

/**
 * Action and patch function that returns variable information from the ARE handle.
 *
 * INT_VAR index          Index of the variable structure to query information about. Omit if you specify the variable structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the variable to query. Omit if you specify the variable structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET name               Returns the name of the variable.
 * RET value              Returns the value of the variable.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_variable
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
  name
  value
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~variable~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~variable~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 name (32) NULL
      READ_SLONG 0x28 value
    END
  END
END

/**
 * Action and patch function that returns explored bitmap data from the ARE handle.
 *
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET explored           Returns explored bitmap information as a string. Returns an empty string if the area
 *                        doesn't have any explored bitmap data defined.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_explored
INT_VAR
  silent = 0
STR_VAR
  are = ~are~
RET
  success
  explored
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SPRINT explored $~%are%~(~explored~)
END

/**
 * Action and patch function that returns door information from the ARE handle.
 *
 * INT_VAR index          Index of the door structure to query information about. Omit if you specify the door structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the door structure to query. Omit if you specify the door structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY door         Returns an associative array with information about the specified door structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_door" function,
 *                        e.g. $door("flags"). Field names for bounding boxes are named "min_x_open", "max_x_open", "min_x_closed", ...
 *                        Container vertices and impeded cells are stored as combined X/Y coordinates in $container("vertex_open" "<idx>"),
 *                        $container("vertex_closed" "<idx>"), $container("cell_closed" "<idx>"), and $container("cell_closed" "<idx>") respectively.
 *                        $container("vertex_open"), etc., contains the number of vertex or cell entries.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_door
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  door
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~door~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~door~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $door(~name~) (32) NULL
      READ_ASCII 0x20 $door(~wed_id~) (8) NULL
      READ_LONG 0x28 $door(~flags~)
      READ_SHORT 0x30 $door(~num_vertices_open~)
      READ_SHORT 0x32 $door(~num_vertices_closed~)
      READ_SSHORT 0x38 $door(~min_x_open~)
      READ_SSHORT 0x3a $door(~min_y_open~)
      READ_SSHORT 0x3c $door(~max_x_open~)
      READ_SSHORT 0x3e $door(~max_y_open~)
      READ_SSHORT 0x40 $door(~min_x_closed~)
      READ_SSHORT 0x42 $door(~min_y_closed~)
      READ_SSHORT 0x44 $door(~max_x_closed~)
      READ_SSHORT 0x46 $door(~max_y_closed~)
      READ_SHORT 0x4c $door(~num_cells_open~)
      READ_SHORT 0x4e $door(~num_cells_closed~)
      READ_ASCII 0x58 $door(~open_wav~) (8) NULL
      READ_ASCII 0x60 $door(~close_wav~) (8) NULL
      READ_LONG 0x68 $door(~cursor_idx~)
      READ_SHORT 0x6c $door(~trap_detect~)
      READ_SHORT 0x6e $door(~trap_remove~)
      READ_SHORT 0x70 $door(~trap_active~)
      READ_SHORT 0x72 $door(~trap_status~)
      READ_SSHORT 0x74 $door(~trap_loc_x~)
      READ_SSHORT 0x76 $door(~trap_loc_y~)
      READ_ASCII 0x78 $door(~key_resref~) (8) NULL
      READ_ASCII 0x80 $door(~door_script~) (8) NULL
      READ_LONG 0x88 $door(~detect_diff~)
      READ_LONG 0x8c $door(~lock_diff~)
      READ_SSHORT 0x90 $door(~open_loc_x~)
      READ_SSHORT 0x92 $door(~open_loc_y~)
      READ_SSHORT 0x94 $door(~close_loc_x~)
      READ_SSHORT 0x96 $door(~close_loc_y~)
      READ_SLONG 0x98 $door(~lockpick_strref~)
      READ_ASCII 0x9c $door(~travel_trigger~) (24) NULL
      READ_SLONG 0xb4 $door(~dlg_strref~)
      READ_ASCII 0xb8 $door(~dlg_resref~) (8) NULL
    END

    // storing vertex lists
    ACTION_FOR_EACH array IN ~vertex_open~ ~vertex_closed~ ~cell_open~ ~cell_closed~ BEGIN
      OUTER_SET count = $~%are%~(~door~ ~%index%~ ~%array%~)
      OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
        OUTER_SET $door(~%array%~ ~%idx%~) = $~%are%~(~door~ ~%index%~ ~%array%~ ~%idx%~)
      END
      OUTER_SET $door(~%array%~) = count
    END
  END
END

/**
 * Action and patch function that returns animation information from the ARE handle.
 *
 * INT_VAR index          Index of the animation structure to query information about. Omit if you specify the animation structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the animation structure to query. Omit if you specify the animation structure by index.
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY animation    Returns an associative array with information about the specified animation structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_animation" function,
 *                        e.g. $animation("loc_x").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_animation
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
RET_ARRAY
  animation
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index silent STR_VAR are type = ~animation~ struct_name = EVAL ~%name%~ RET success index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~animation~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $animation(~name~) (32) NULL
      READ_SSHORT 0x20 $animation(~loc_x~)
      READ_SSHORT 0x22 $animation(~loc_y~)
      READ_LONG 0x24 $animation(~schedule~)
      READ_ASCII 0x28 $animation(~bam_resref~) (8) NULL
      READ_SHORT 0x30 $animation(~bam_seq~)
      READ_SHORT 0x32 $animation(~bam_frame~)
      READ_LONG 0x34 $animation(~flags~)
      READ_SSHORT 0x38 $animation(~loc_z~)
      READ_SHORT 0x3a $animation(~transparent~)
      READ_SHORT 0x3c $animation(~init_frame~)
      READ_BYTE 0x3e $animation(~loop_chance~)
      READ_BYTE 0x3f $animation(~skip_cycles~)
      READ_ASCII 0x40 $animation(~bmp_resref~) (8) NULL
      READ_SHORT 0x48 $animation(~width~)
      READ_SHORT 0x4a $animation(~height~)
    END
  END
END

/**
 * Action and patch function that returns songs information from the ARE handle.
 *
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY songs        Returns an associative array with information about the songs structure of the area.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_alter_songs" function,
 *                        e.g. $songs("song_day").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_songs
INT_VAR
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  songs
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~songs~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_SLONG 0x00 $songs(~song_day~)
      READ_SLONG 0x04 $songs(~song_night~)
      READ_SLONG 0x08 $songs(~song_victory~)
      READ_SLONG 0x0c $songs(~song_battle~)
      READ_SLONG 0x10 $songs(~song_defeat~)
      READ_SLONG 0x14 $songs(~song_day_alt~)
      READ_SLONG 0x18 $songs(~song_night_alt~)
      READ_SLONG 0x1c $songs(~song_victory_alt~)
      READ_SLONG 0x20 $songs(~song_battle_alt~)
      READ_SLONG 0x24 $songs(~song_defeat_alt~)
      READ_ASCII 0x28 $songs(~song_day0~) (8) NULL
      READ_ASCII 0x30 $songs(~song_day1~) (8) NULL
      READ_LONG 0x38 $songs(~song_day_vol~)
      READ_ASCII 0x3c $songs(~song_night0~) (8) NULL
      READ_ASCII 0x44 $songs(~song_night1~) (8) NULL
      READ_LONG 0x4c $songs(~song_night_vol~)
      READ_SLONG 0x50 $songs(~reverb~)
    END
  END
END

/**
 * Action and patch function that returns rest encounter information from the ARE handle.
 *
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY rest         Returns an associative array with information about the rest encounter structure of the area.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_alter_rest" function,
 *                        e.g. $rest("spawn_num").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_rest
INT_VAR
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  rest
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~rest~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $rest(~name~) (32) NULL
      FOR (i = 0; i < 10; ++i) BEGIN
        READ_SLONG (0x20 + i * 4) $rest(~cre_strref%i%~)
        READ_ASCII (0x48 + i * 8) $rest(~cre_resref%i%~) (8) NULL
      END
      READ_SHORT 0x98 $rest(~spawn_num~)
      READ_SHORT 0x9a $rest(~difficulty~)
      READ_SLONG 0x9c $rest(~duration~)
      READ_SHORT 0xa0 $rest(~wander_distance~)
      READ_SHORT 0xa2 $rest(~follow_distance~)
      READ_SHORT 0xa4 $rest(~max_num~)
      READ_SHORT 0xa6 $rest(~enable~)
      READ_SHORT 0xa8 $rest(~day_prob~)
      READ_SHORT 0xaa $rest(~night_prob~)
    END
  END
END

/**
 * Action and patch function that returns automap note information from the ARE handle.
 *
 * INT_VAR index          Index of the automap note structure to query information about. (Default: -1)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY automap      Returns an associative array with information about the specified automap note structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_automap" function,
 *                        e.g. $automap("loc_x").
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_automap
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  automap
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    OUTER_SET num_notes = $~%are%~(~automap~)
    ACTION_IF (index < 0 || index >= num_notes) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Index of "automap" is out of bounds: %index%~
      END
    END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~automap~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      PATCH_IF (is_v1 && is_pst) BEGIN
        READ_SLONG 0x00 $automap(~loc_x~)
        READ_SLONG 0x04 $automap(~loc_y~)
        SPRINT $automap(~note_text~) $~%are%~(~automap~ ~%index%~ ~text~)
        READ_LONG 0x1fc $automap(~color~)
      END ELSE BEGIN
        READ_SSHORT 0x00 $automap(~loc_x~)
        READ_SSHORT 0x02 $automap(~loc_y~)
        SET $automap(~note_strref~) = $~%are%~(~automap~ ~%index%~ ~text~)
        SET $automap(~strref_loc~) = $~%are%~(~automap~ ~%index%~ ~is_tlk~)
        READ_SHORT 0x0a $automap(~color~)
        READ_LONG 0x0c $automap(~note_id~)
      END
    END
  END
END

/**
 * Action and patch function that returns projectile trap information from the ARE handle.
 *
 * INT_VAR index          Index of the projectile trap structure to query information about. (Default: -1)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the query was successful, 0 otherwise.
 * RET_ARRAY projectile   Returns an associative array with information about the specified projectile trap structure.
 *                        Array fields are the same as the structure-specific parameters from the "a7#batch_are_add_projectile" function,
 *                        e.g. $projectile("missile_num").
 *                        Projectile trap effects are stored as raw EFF V2 data strings in $projectile("embedded_eff" "<idx>").
 *                        Their content can be accessed by the INNER/OUTER_PATCH commands.
 *                        $projectile("embedded_eff") contains the number of effect entries.
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_get_projectile
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  projectile
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    OUTER_SET num_projectiles = $~%are%~(~projectile~)
    ACTION_IF (index < 0 || index >= num_projectiles) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Index of "projectile" is out of bounds: %index%~
      END
    END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SPRINT buffer $~%are%~(~projectile~ ~%index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_ASCII 0x00 $projectile(~pro_resref~) (8) NULL
      READ_SHORT 0x0e $projectile(~missile_num~)
      READ_SHORT 0x10 $projectile(~frequency~)
      READ_SHORT 0x12 $projectile(~duration~)
      READ_SSHORT 0x14 $projectile(~loc_x~)
      READ_SSHORT 0x16 $projectile(~loc_y~)
      READ_SSHORT 0x18 $projectile(~loc_z~)
      READ_BYTE 0x1a $projectile(~target~)
      READ_BYTE 0x1b $projectile(~creator~)
    END
  END

  // storing effects list
  OUTER_SET count = $~%are%~(~projectile~ ~%index%~ ~effect~)
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    OUTER_SPRINT $projectile(~embedded_eff~ ~%idx%~) $~%are%~(~projectile~ ~%index%~ ~effect~ ~%idx%~)
  END
  OUTER_SET $projectile(~num_embedded_eff~) = count
  OUTER_SET $projectile(~embedded_eff~) = count
END


/**
 * Action and patch function that alters basic area attributes on the ARE handle.
 *
 * INT_VAR last_saved             New time stamp of the last save (seconds, in real time). (Default: no change)
 * INT_VAR area_flags             New area flags (see AREAFLAG.IDS). (Default: no change)
 * INT_VAR area_flags_north       New flags for the ARE resref linked to the northern edge of the map. (Default: no change)
 * INT_VAR area_flags_east        New flags for the ARE resref linked to the eastern edge of the map. (Default: no change)
 * INT_VAR area_flags_south       New flags for the ARE resref linked to the southern edge of the map. (Default: no change)
 * INT_VAR area_flags_west        New flags for the ARE resref linked to the western edge of the map. (Default: no change)
 * INT_VAR area_type              New area type flags (see AREATYPE.IDS). (Default: no change)
 * INT_VAR probability_rain       New rain probability (range: 0-100). (Default: no change)
 * INT_VAR probability_snow       New snow probability (range: 0-100). (Default: no change)
 * INT_VAR probability_fog        New fog probability (range: 0-100). (Default: no change)
 * INT_VAR probability_lightning  New lightning probability (range: 0-100). (Default: no change)
 * INT_VAR overlay_transparency   (EE only) New overlay transparency for water and other secondary overlays (range: 0-255). (Default: no change)
 * INT_VAR area_difficulty_1      (IWD2 only) New average party level
 * INT_VAR area_difficulty_2      (IWD2 only) New average party level requirement for Area difficulty level 2. (Default: no change)
 * INT_VAR area_difficulty_3      (IWD2 only) New average party level requirement for Area difficulty level 3. (Default: no change)
 * INT_VAR silent                 Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                    Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                                Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR version                New ARE file version. Supported version strings are "V9.1" for IWD2-compatible area and "V1.0"
 *                                for all other games. Don't change this attribute unless you know what you're doing. (Default: no change)
 * STR_VAR wed_resref             New WED resref. (Default: no change)
 * STR_VAR area_resref_north      New ARE resref linked to the northern edge of the map. (Default: no change)
 * STR_VAR area_resref_east       New ARE resref linked to the eastern edge of the map. (Default: no change)
 * STR_VAR area_resref_south      New ARE resref linked to the southern edge of the map. (Default: no change)
 * STR_VAR area_resref_west       New ARE resref linked to the western edge of the map. (Default: no change)
 * STR_VAR area_script            New BCS resref for a new area script. (Default: no change)
 * STR_VAR rest_movie_day         (BG2 and EE only) New MVE or WBM movie resref for the morning cinematic. (Default: no change)
 * STR_VAR rest_movie_night       (BG2 and EE only) New MVE or WBM movie resref for the evening cinematic. (Default: no change)
 * RET success                    Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%                Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                                (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_attributes
INT_VAR
  last_saved = A7_ARE_NO_CHANGE
  area_flags = A7_ARE_NO_CHANGE
  area_flags_north = A7_ARE_NO_CHANGE
  area_flags_east = A7_ARE_NO_CHANGE
  area_flags_south = A7_ARE_NO_CHANGE
  area_flags_west = A7_ARE_NO_CHANGE
  area_type = A7_ARE_NO_CHANGE
  probability_rain = A7_ARE_NO_CHANGE
  probability_snow = A7_ARE_NO_CHANGE
  probability_fog = A7_ARE_NO_CHANGE
  probability_lightning = A7_ARE_NO_CHANGE
  overlay_transparency = A7_ARE_NO_CHANGE
  area_difficulty_1 = A7_ARE_NO_CHANGE
  area_difficulty_2 = A7_ARE_NO_CHANGE
  area_difficulty_3 = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  version = ~?~
  wed_resref = ~?~
  area_resref_north = ~?~
  area_resref_east = ~?~
  area_resref_south = ~?~
  area_resref_west = ~?~
  area_script = ~?~
  rest_movie_day = ~?~
  rest_movie_night = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success && NOT ~%version%~ STR_EQ ~?~) BEGIN
    ACTION_IF (~%version%~ STR_EQ ~V1.0~ || ~%version%~ STR_EQ ~V9.1~) BEGIN
      OUTER_SPRINT $~%are%~(~version~) ~%version%~
    END ELSE BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Invalid area version: %version%~
      END
    END
  END

  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH int_var IN ~last_saved~ ~area_flags~ ~area_flags_north~ ~area_flags_east~ ~area_flags_south~
                               ~area_flags_west~ ~area_type~ ~probability_rain~ ~probability_snow~ ~probability_fog~
                               ~probability_lightning~ ~overlay_transparency~
    BEGIN
      OUTER_SET value = EVAL ~%int_var%~
      ACTION_IF (value != A7_ARE_NO_CHANGE) BEGIN
        OUTER_SET $~%are%~(~%int_var%~) = value
      END
    END

    ACTION_IF ($~%are%~(~version~) STR_EQ ~V9.1~) BEGIN
      ACTION_FOR_EACH int_var IN ~area_difficulty_1~ ~area_difficulty_2~ ~area_difficulty_3~ BEGIN
        OUTER_SET value = EVAL ~%int_var%~
        ACTION_IF (value != A7_ARE_NO_CHANGE) BEGIN
          OUTER_SET $~%are%~(~%int_var%~) = value
        END
      END
    END

    ACTION_FOR_EACH str_var IN ~wed_resref~ ~area_resref_north~ ~area_resref_east~ ~area_resref_south~
                               ~area_resref_west~ ~area_script~ ~rest_movie_day~ ~rest_movie_night~ BEGIN
      OUTER_SPRINT value EVAL ~%%str_var%%~
      ACTION_IF (NOT ~%value%~ STR_EQ ~?~) BEGIN
        OUTER_SET len = STRING_LENGTH ~%value%~
        ACTION_IF (len <= 8) BEGIN
          OUTER_SPRINT $~%are%~(~%str_var%~) ~%value%~
        END ELSE BEGIN
          OUTER_SET success = 0
          ACTION_IF (NOT silent) BEGIN
            WARN ~WARNING: "%str_var%" string must not exceed 8 characters. Skipping.~
          END
        END
      END
    END
  END
END

/**
 * Action and patch function that adds a new actor to the ARE handle.
 *
 * INT_VAR loc_x                Current X coordinate of the actor. (Default: 0)
 * INT_VAR loc_y                Current Y coordinate of the actor. (Default: 0)
 * INT_VAR dest_x               Destination X coordinate of the actor. (Default: same as "loc_x")
 * INT_VAR dest_y               Destination Y coordinate of the actor. (Default: same as "loc_y")
 * INT_VAR flags                Actor flags. (Default: 1 / CRE not embedded)
 * INT_VAR is_spawned           Whether the actor is a spawned creature. (Default: 0)
 * INT_VAR area_difficulty      (IWD2) Area difficulty mask. (Default: 0)
 * INT_VAR animation            Actor animation id (not used by the engine). (Default: from specified CRE)
 * INT_VAR orientation          Actor orientation. (0=South, 4=West, 8=North, 12=East). (Default: 0)
 * INT_VAR expiry               Actor removal timer in absolute ticks. (Default: -1 / never)
 * INT_VAR wander_distance      Movement restriction distance. (Default: 0)
 * INT_VAR follow_distance      Movement restriction distance (move to object). (Default: 0)
 * INT_VAR schedule             Actor hourly appearance schedule. Each bit refers to a specific hour of the day. (Default: always active)
 * INT_VAR num_times_talked_to  NumTimesTalkedTo() the actor. (Default: 0)
 * INT_VAR silent               Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                  Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                              Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name                 Name of the actor. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR dlg_resref           Dialog resref. (Default: empty resref)
 * STR_VAR bcs_override         Override script. (Default: empty resref)
 * STR_VAR bcs_general          General script. (Default: empty resref)
 * STR_VAR bcs_class            Class script. (Default: empty resref)
 * STR_VAR bcs_race             Race script. (Default: empty resref)
 * STR_VAR bcs_default          Default script. (Default: empty resref)
 * STR_VAR bcs_specific         Specific script. (Default: empty resref)
 * STR_VAR bcs_special1         (IWD2) Special 1 script. (Default: empty resref)
 * STR_VAR bcs_special2         (IWD2) Special 2 script. (Default: empty resref)
 * STR_VAR bcs_special3         (IWD2) Special 3 script. (Default: empty resref)
 * STR_VAR bcs_combat           (IWD2) Combat script. (Default: empty resref)
 * STR_VAR bcs_movement         (IWD2) Movement script. (Default: empty resref)
 * STR_VAR bcs_team             (IWD2) Team script. (Default: empty resref)
 * STR_VAR cre_resref           The actor's CRE resref. (Default: empty resref)
 * STR_VAR cre_embedded         CRE data string, full path to the CRE file, or resref of the CRE resource that should be embedded in the
 *                              actor structure. Only considered if "flags" are set to embed CRE data. (Default: uses "cre_resref" if not set)
 * RET success                  Returns 1 if the operation was successful, 0 otherwise.
 * RET index                    Returns the index of the added actor structure if successful, -1 otherwise
 * RET_ARRAY %are%              Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                              (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_actor
INT_VAR
  loc_x = 0
  loc_y = 0
  dest_x = loc_x
  dest_y = loc_y
  flags = BIT0
  is_spawned = 0
  area_difficulty = 0
  animation = "-1"
  orientation = 0
  expiry = "-1"
  wander_distance = 0
  follow_distance = 0
  schedule = 0x00ffffff
  num_times_talked_to = 0
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  dlg_resref = ~~
  bcs_override = ~~
  bcs_general = ~~
  bcs_class = ~~
  bcs_race = ~~
  bcs_default = ~~
  bcs_specific = ~~
  bcs_special1 = ~~
  bcs_special2 = ~~
  bcs_special3 = ~~
  bcs_combat = ~~
  bcs_movement = ~~
  bcs_team = ~~
  cre_resref = ~~
  cre_embedded = EVAL ~%cre_resref%~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_actors = $~%are%~(~actor~)

  // validating structure name
  ACTION_IF (success && STRING_LENGTH ~%name%~ > 32) BEGIN
    LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Actor name is too long. Removing excess characters.~
    END
  END

  // validating resref parameters
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~dlg_resref~ ~bcs_override~ ~bcs_general~ ~bcs_class~ ~bcs_race~ ~bcs_default~ ~bcs_specific~
                             ~bcs_special1~ ~bcs_special2~ ~bcs_special3~ ~bcs_combat~ ~bcs_movement~ ~bcs_team~ ~cre_resref~
    BEGIN
      OUTER_SPRINT value EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%value%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating embedded cre
  OUTER_SET is_cre_buffer = 0
  ACTION_IF (success && (flags & BIT0) == 0) BEGIN
    LAF a7#__are_actor_get_embedded_cre
      INT_VAR index = num_actors silent
      STR_VAR are cre_resref cre_embedded
      RET success is_cre_buffer cre_buffer cre_buffer_res cre_buffer_name
    END
  END

  // autodetecting creature animation id
  ACTION_IF (success && animation == "-1") BEGIN
    ACTION_IF (NOT is_cre_buffer && NOT ~%cre_resref%~ STR_EQ ~~ && FILE_EXISTS_IN_GAME ~%cre_resref%.cre~) BEGIN
      OUTER_SET is_silent = IS_SILENT
      ACTION_IF (NOT is_silent) BEGIN SILENT END
      COPY_EXISTING ~%cre_resref%.cre~ ~override~ READ_LONG 0x28 animation BUT_ONLY
      ACTION_IF (NOT is_silent) BEGIN VERBOSE END
    END ELSE BEGIN
      // following default engine behavior for embedded CREs
      OUTER_SET animation = 0
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~actor~ ~%num_actors%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 272

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 loc_x
      WRITE_SHORT 0x22 loc_y
      WRITE_SHORT 0x24 dest_x
      WRITE_SHORT 0x26 dest_y
      WRITE_LONG 0x28 flags
      WRITE_SHORT 0x2c (is_spawned != 0)
      PATCH_IF (NOT is_v1) BEGIN
        WRITE_BYTE 0x2f area_difficulty
      END
      WRITE_LONG 0x30 animation
      WRITE_SHORT 0x34 orientation
      WRITE_LONG 0x38 expiry
      WRITE_SHORT 0x3c wander_distance
      WRITE_SHORT 0x3e follow_distance
      WRITE_LONG 0x40 schedule
      WRITE_LONG 0x44 num_times_talked_to
      WRITE_ASCIIE 0x48 ~%dlg_resref%~ (8)
      WRITE_ASCIIE 0x50 ~%bcs_override%~ (8)
      PATCH_IF (is_v1) BEGIN
        WRITE_ASCIIE 0x58 ~%bcs_general%~ (8)
        WRITE_ASCIIE 0x60 ~%bcs_class%~ (8)
        WRITE_ASCIIE 0x68 ~%bcs_race%~ (8)
        WRITE_ASCIIE 0x70 ~%bcs_default%~ (8)
        WRITE_ASCIIE 0x78 ~%bcs_specific%~ (8)
      END ELSE BEGIN
        WRITE_ASCIIE 0x58 ~%bcs_special3%~ (8)
        WRITE_ASCIIE 0x60 ~%bcs_special2%~ (8)
        WRITE_ASCIIE 0x68 ~%bcs_combat%~ (8)
        WRITE_ASCIIE 0x70 ~%bcs_movement%~ (8)
        WRITE_ASCIIE 0x78 ~%bcs_team%~ (8)
        WRITE_ASCIIE 0x90 ~%bcs_special1%~ (8)
      END

      // embedded / referenced CRE
      PATCH_IF ((flags & BIT0) == 0) BEGIN
        // embedded CRE
        SET $~%are%~(~actor~ ~%num_actors%~ ~cre_attached~) = 1
        SPRINT $~%are%~(~actor~ ~%num_actors%~ ~cre~) ~%cre_buffer%~

        TO_UPPER ~cre_buffer_res~
        INNER_PATCH_SAVE cre_buffer_res ~%cre_buffer_res%~ BEGIN
          READ_ASCII 0 first_letter (1)
          WRITE_ASCII 0 ~*~ (1)
        END
        WRITE_ASCIIE 0x2e ~%first_letter%~ (1)
        WRITE_ASCIIE 0x80 ~%cre_buffer_res%~ (8)
        WRITE_LONG 0x8c STRING_LENGTH ~%cre_buffer%~
        WRITE_ASCIIE 0x90 ~%cre_buffer_name%~ (32)
      END ELSE BEGIN
        // referenced CRE
        SET $~%are%~(~actor~ ~%num_actors%~ ~cre_attached~) = 0
        SPRINT $~%are%~(~actor~ ~%num_actors%~ ~cre~) ~~
        WRITE_ASCIIE 0x80 ~%cre_resref%~ (8)
        WRITE_LONG 0x88 0
        WRITE_LONG 0x8c 0
      END
    END
    OUTER_SPRINT $~%are%~(~actor~ ~%num_actors%~) ~%buffer%~
    OUTER_SET $~%are%~(~actor~) += 1
    OUTER_SET index = num_actors
  END
END

/**
 * Action and patch function that alters attributes of an existing actor structure on the ARE handle.
 *
 * INT_VAR actor_index          Index of the actor structure to patch. Omit if you specify the actor structure by name.
 * INT_VAR loc_x                New current X coordinate of the actor. (Default: no change)
 * INT_VAR loc_y                New current Y coordinate of the actor. (Default: no change)
 * INT_VAR dest_x               New destination X coordinate of the actor. (Default: no change)
 * INT_VAR dest_y               New destination Y coordinate of the actor. (Default: no change)
 * INT_VAR flags                New actor flags. (Default: no change)
 * INT_VAR is_spawned           New value for whether the actor is a spawned creature. (Default: no change)
 * INT_VAR area_difficulty      (IWD2) New area difficulty mask. (Default: no change)
 * INT_VAR animation            New actor animation id (not used by the engine). (Default: no change)
 * INT_VAR orientation          New actor orientation (0=South, 4=West, 8=North, 12=East). (Default: no change)
 * INT_VAR expiry               New actor removal timer in absolute ticks. (Default: no change)
 * INT_VAR wander_distance      New movement restriction distance. (Default: no change)
 * INT_VAR follow_distance      New movement restriction distance (move to object). (Default: no change)
 * INT_VAR schedule             New hourly appearance schedule. Each bit refers to a specific hour of the day. (Default: no change)
 * INT_VAR num_times_talked_to  New NumTimesTalkedTo() value of the actor. (Default: no change)
 * INT_VAR silent               Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                  Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                              Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR actor_name           Name of the actor structure to patch. Omit if you specify the actor structure by index.
 * STR_VAR name                 New name of the actor. May not be longer than 32 characters. (Default: no change)
 * STR_VAR dlg_resref           New dialog resref. (Default: no change)
 * STR_VAR bcs_override         New override script. (Default: no change)
 * STR_VAR bcs_general          New general script. (Default: no change)
 * STR_VAR bcs_class            New class script. (Default: no change)
 * STR_VAR bcs_race             New race script. (Default: no change)
 * STR_VAR bcs_default          New default script. (Default: no change)
 * STR_VAR bcs_specific         New specific script. (Default: no change)
 * STR_VAR bcs_special1         (IWD2) New special 1 script. (Default: no change)
 * STR_VAR bcs_special2         (IWD2) New special 2 script. (Default: no change)
 * STR_VAR bcs_special3         (IWD2) New special 3 script. (Default: no change)
 * STR_VAR bcs_combat           (IWD2) New combat script. (Default: no change)
 * STR_VAR bcs_movement         (IWD2) New movement script. (Default: no change)
 * STR_VAR bcs_team             (IWD2) New team script. (Default: no change)
 * STR_VAR cre_resref           New actor's CRE resref. (Default: no change)
 * STR_VAR cre_embedded         New embedded CRE as data string, full path to the CRE file, or resref of the CRE resource. Only considered
 *                              if "flags" are set to embed CRE data. (Default: no change)
 * RET success                  Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%              Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                              (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_actor
INT_VAR
  actor_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  dest_x = A7_ARE_NO_CHANGE
  dest_y = A7_ARE_NO_CHANGE
  flags = A7_ARE_NO_CHANGE
  is_spawned = A7_ARE_NO_CHANGE
  area_difficulty = A7_ARE_NO_CHANGE
  animation = A7_ARE_NO_CHANGE
  orientation = A7_ARE_NO_CHANGE
  expiry = A7_ARE_NO_CHANGE
  wander_distance = A7_ARE_NO_CHANGE
  follow_distance = A7_ARE_NO_CHANGE
  schedule = A7_ARE_NO_CHANGE
  num_times_talked_to = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  actor_name = ~~
  name = ~?~
  dlg_resref = ~?~
  bcs_override = ~?~
  bcs_general = ~?~
  bcs_class = ~?~
  bcs_race = ~?~
  bcs_default = ~?~
  bcs_specific = ~?~
  bcs_special1 = ~?~
  bcs_special2 = ~?~
  bcs_special3 = ~?~
  bcs_combat = ~?~
  bcs_movement = ~?~
  bcs_team = ~?~
  cre_resref = ~?~
  cre_embedded = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = actor_index silent STR_VAR are type = ~actor~ struct_name = EVAL ~%actor_name%~ RET success actor_index = index END
  END

  // validating structure name
  ACTION_IF (success && STRING_LENGTH ~%name%~ > 32) BEGIN
    LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Actor name is too long. Removing excess characters.~
    END
  END

  // validating resref parameters
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~dlg_resref~ ~bcs_override~ ~bcs_general~ ~bcs_class~ ~bcs_race~ ~bcs_default~ ~bcs_specific~
                             ~bcs_special1~ ~bcs_special2~ ~bcs_special3~ ~bcs_combat~ ~bcs_movement~ ~bcs_team~ ~cre_resref~
    BEGIN
      OUTER_SPRINT value EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%value%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~actor~ ~%actor_index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_LONG 0x28 flags_original
    END
    OUTER_SET is_embed = (flags == A7_ARE_NO_CHANGE && (flags_original & BIT0) == 0) || (flags == A7_ARE_NO_CHANGE && (flags & BIT0) == 0)
  END

  // validating embedded cre
  OUTER_SET is_cre_buffer = 0
  ACTION_IF (success && is_embed && NOT ~%cre_embedded%~ STR_EQ ~?~) BEGIN
    LAF a7#__are_actor_get_embedded_cre
      INT_VAR index = actor_index silent
      STR_VAR are cre_embedded
      RET success is_cre_buffer cre_buffer cre_buffer_res cre_buffer_name
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~actor~ ~%actor_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END
      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x22 loc_y END
      PATCH_IF (dest_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x24 dest_x END
      PATCH_IF (dest_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x26 dest_y END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x28 flags END
      PATCH_IF (is_spawned != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x2c (is_spawned != 0) END
      PATCH_IF (NOT is_v1) BEGIN
        PATCH_IF (area_difficulty != A7_ARE_NO_CHANGE) BEGIN WRITE_BYTE 0x2f area_difficulty END
      END
      PATCH_IF (animation != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x30 animation END
      PATCH_IF (orientation != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x34 orientation END
      PATCH_IF (expiry != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x38 expiry END
      PATCH_IF (wander_distance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x3c wander_distance END
      PATCH_IF (follow_distance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x3e follow_distance END
      PATCH_IF (schedule != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x40 schedule END
      PATCH_IF (num_times_talked_to != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x44 num_times_talked_to END
      PATCH_IF (NOT ~%dlg_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x48 ~%dlg_resref%~ (8) END
      PATCH_IF (NOT ~%bcs_override%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x50 ~%bcs_override%~ (8) END
      PATCH_IF (is_v1) BEGIN
        PATCH_IF (NOT ~%bcs_general%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x58 ~%bcs_general%~ (8) END
        PATCH_IF (NOT ~%bcs_class%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x60 ~%bcs_class%~ (8) END
        PATCH_IF (NOT ~%bcs_race%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x68 ~%bcs_race%~ (8) END
        PATCH_IF (NOT ~%bcs_default%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x70 ~%bcs_default%~ (8) END
        PATCH_IF (NOT ~%bcs_specific%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x78 ~%bcs_specific%~ (8) END
      END ELSE BEGIN
        PATCH_IF (NOT ~%bcs_special3%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x58 ~%bcs_special3%~ (8) END
        PATCH_IF (NOT ~%bcs_special2%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x60 ~%bcs_special2%~ (8) END
        PATCH_IF (NOT ~%bcs_combat%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x68 ~%bcs_combat%~ (8) END
        PATCH_IF (NOT ~%bcs_movement%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x70 ~%bcs_movement%~ (8) END
        PATCH_IF (NOT ~%bcs_team%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x78 ~%bcs_team%~ (8) END
        PATCH_IF (NOT ~%bcs_special1%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x90 ~%bcs_special1%~ (8) END
      END

      // embedded / referenced CRE
      PATCH_IF (is_embed && is_cre_buffer) BEGIN
        // embedded CRE
        SET $~%are%~(~actor~ ~%actor_index%~ ~cre_attached~) = 1
        SPRINT $~%are%~(~actor~ ~%actor_index%~ ~cre~) ~%cre_buffer%~

        TO_UPPER ~cre_buffer_res~
        INNER_PATCH_SAVE cre_buffer_res ~%cre_buffer_res%~ BEGIN
          READ_ASCII 0 first_letter (1)
          WRITE_ASCII 0 ~*~ (1)
        END
        WRITE_ASCIIE 0x2e ~%first_letter%~ (1)
        WRITE_ASCIIE 0x80 ~%cre_buffer_res%~ (8)
        WRITE_LONG 0x8c (STRING_LENGTH ~%cre_buffer%~)
        WRITE_ASCIIE 0x90 ~%cre_buffer_name%~ (32)
      END ELSE BEGIN
        // referenced CRE
        SET $~%are%~(~actor~ ~%actor_index%~ ~cre_attached~) = 0
        SPRINT $~%are%~(~actor~ ~%actor_index%~ ~cre~) ~~
        WRITE_ASCIIE 0x80 ~%cre_resref%~ (8)
        WRITE_LONG 0x88 0
        WRITE_LONG 0x8c 0
      END
    END
    OUTER_SPRINT $~%are%~(~actor~ ~%actor_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing actor structure from the ARE handle.
 *
 * INT_VAR actor_index  Index of the actor structure to remove. Omit if you specify the actor structure by name.
 * INT_VAR silent       Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are          Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                      Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR actor_name   Name of the actor structure to remove. Omit if you specify the actor structure by index.
 * RET success          Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%      Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                      (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_actor
INT_VAR
  actor_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  actor_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = actor_index silent STR_VAR are type = ~actor~ struct_name = EVAL ~%actor_name%~ RET success actor_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_actors = $~%are%~(~actor~)
    OUTER_FOR (idx = actor_index + 1; idx < num_actors; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~actor~ ~%prev_idx%~) $~%are%~(~actor~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~actor~ ~%prev_idx%~ ~name~) $~%are%~(~actor~ ~%idx%~ ~name~)
      OUTER_SET $~%are%~(~actor~ ~%prev_idx%~ ~cre_attached~) = $~%are%~(~actor~ ~%idx%~ ~cre_attached~)
      OUTER_SPRINT $~%are%~(~actor~ ~%prev_idx%~ ~cre~) $~%are%~(~actor~ ~%idx%~ ~cre~)
    END
    OUTER_SET $~%are%~(~actor~) = num_actors - 1
  END
END

/**
 * Action and patch function that moves the position or changes the orientation of an actor on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR actor_index  Index of the actor structure to move. Omit if you specify the actor structure by name.
 * INT_VAR x            Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y            Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR turn         Amount of units to advance the actor's orientation. A full turn consists of 16 units. Specify positive values to turn in
 *                      clockwise direction and negative values to turn in counter-clockwise direction.
 * INT_VAR silent       Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are          Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                      Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR actor_name   Name of the actor structure to move. Omit if you specify the actor structure by index.
 * RET success          Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%      Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                      (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_actor
INT_VAR
  actor_index = "-1"
  x = 0
  y = 0
  turn = 0
  silent = 0
STR_VAR
  are = ~are~
  actor_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = actor_index silent STR_VAR are type = ~actor~ struct_name = EVAL ~%actor_name%~ RET success actor_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0 || turn != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~actor~ ~%actor_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x20 (THIS + x)
      WRITE_SHORT 0x22 (THIS + y)
      WRITE_SHORT 0x24 (THIS + x)
      WRITE_SHORT 0x26 (THIS + y)
      WRITE_SHORT 0x34 ((((THIS + turn) MODULO 16) + 16) MODULO 16)
    END
    OUTER_SPRINT $~%are%~(~actor~ ~%actor_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new region to the ARE handle.
 *
 * INT_VAR type               Region type (0=proximity trigger, 1=info point, 2=travel region). (Default: 0)
 * INT_VAR cursor_idx         Cursor index (CURSORS.BAM). (Default: 0)
 * INT_VAR flags              Region flags. (Default: 0)
 * INT_VAR info_point_strref  Strref of information text (for info points). (Default: -1)
 * INT_VAR trap_detect        Trap detection difficulty (%). (Default: 0)
 * INT_VAR trap_remove        Trap removal difficulty (%). (Default: 0)
 * INT_VAR trap_active        Whether the region is trapped. (Default: 0)
 * INT_VAR trap_status        Whether the region trap has been detected. (Default: 0)
 * INT_VAR loc_x              X coordinate of the trap launch location. (Default: 0)
 * INT_VAR loc_y              Y coordinate of the trap launch location. (Default: 0)
 * INT_VAR alt_x              X coordinate of the alternative use point. (IWD2: X coordinate of the override use point.) (Default: 0)
 * INT_VAR alt_y              Y coordinate of the alternative use point. (IWD2: Y coordinate of the override use point.) (Default: 0)
 * INT_VAR alt2_x             (IWD2) X coordinate of the alternative use point. (Default: 0)
 * INT_VAR alt2_y             (IWD2) Y coordinate of the alternative use point. (Default: 0)
 * INT_VAR talk_loc_x         (PST/PSTEE) X coordinate of the talk location. (Default: 0)
 * INT_VAR talk_loc_y         (PST/PSTEE) Y coordinate of the talk location. (Default: 0)
 * INT_VAR speaker_strref     (PST/PSTEE) Strref of the speaker name. (Default: -1)
 * INT_VAR num_vertices       Number of region vertices to add. (Default: 0)
 * INT_VAR vertex_0, ...      Array "vertex" with "num_vertices" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                            Alternate notation: $vertex("0"), ...
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name               Name of the region. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR destination_area   Resref of the destination area (for travel regions). (Default: empty resref)
 * STR_VAR destination_name   Entrance name in the destination area (for travel regions). (Default: empty string)
 * STR_VAR key_resref         Resref of a key item. (Default: empty resref)
 * STR_VAR script_resref      Resref of the region script. (Default: empty resref)
 * STR_VAR sound_resref       (PST/PSTEE) Resref of an associated sound. (Default: empty resref)
 * STR_VAR dialog_resref      (PST/PSTEE) Resref of a dialog file. (Default: empty resref)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET index                  Returns the index of the added region structure if successful, -1 otherwise
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_region
INT_VAR
  type = 0
  cursor_idx = 0
  flags = 0
  info_point_strref = "-1"
  trap_detect = 0
  trap_remove = 0
  trap_active = 0
  trap_status = 0
  loc_x = 0
  loc_y = 0
  alt_x = 0
  alt_y = 0
  alt2_x = 0
  alt2_y = 0
  talk_loc_x = 0
  talk_loc_y = 0
  speaker_strref = "-1"
  num_vertices = 0
  // vertex_0 = x | (y << 16) ...
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  destination_area = ~~
  destination_name = ~~
  key_resref = ~~
  script_resref = ~~
  sound_resref = ~~
  dialog_resref = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_regions = $~%are%~(~region~)

  // validating names
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~name~ ~destination_name~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 32) BEGIN
        LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string RET string = substring END
        OUTER_SPRINT EVAL ~%param%~ ~%string%~
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" is too long. Removing excess characters.~
        END
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~destination_area~ ~key_resref~ ~script_resref~ ~sound_resref~ ~dialog_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating vertex array
  ACTION_IF (success) BEGIN
    OUTER_SET num_vertices = (num_vertices < 0) ? 0 : num_vertices
    LAF a7#__are_validate_array INT_VAR count = num_vertices STR_VAR name = ~vertex~ RET result END
    ACTION_IF (result < num_vertices) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Not enough vertex entries defined (expected: %num_vertices%, found: %result%)~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~region~ ~%num_regions%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 196

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 type
      LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices STR_VAR array = ~vertex~ RET min_x max_x min_y max_y END
      WRITE_SHORT 0x22 min_x
      WRITE_SHORT 0x24 min_y
      WRITE_SHORT 0x26 max_x
      WRITE_SHORT 0x28 max_y
      WRITE_SHORT 0x2a num_vertices
      WRITE_LONG 0x34 cursor_idx
      WRITE_ASCIIE 0x38 ~%destination_area%~ (8)
      WRITE_ASCIIE 0x40 ~%destination_name%~ (32)
      WRITE_LONG 0x60 flags
      WRITE_LONG 0x64 info_point_strref
      WRITE_SHORT 0x68 trap_detect
      WRITE_SHORT 0x6a trap_remove
      WRITE_SHORT 0x6c (trap_active != 0)
      WRITE_SHORT 0x6e (trap_status != 0)
      WRITE_SHORT 0x70 loc_x
      WRITE_SHORT 0x72 loc_y
      WRITE_ASCIIE 0x74 ~%key_resref%~ (8)
      WRITE_ASCIIE 0x7c ~%script_resref%~ (8)
      WRITE_SHORT 0x84 alt_x
      WRITE_SHORT 0x86 alt_y
      PATCH_IF (is_v1 && (is_pst || is_pstee)) BEGIN
        WRITE_ASCIIE 0xac ~%sound_resref%~ (8)
        WRITE_SHORT 0xb4 talk_loc_x
        WRITE_SHORT 0xb6 talk_loc_y
        WRITE_LONG 0xb8 speaker_strref
        WRITE_ASCIIE 0xbc ~%dialog_resref%~ (8)
      END ELSE PATCH_IF (NOT is_v1) BEGIN
        WRITE_LONG 0x88 alt2_x
        WRITE_LONG 0x8c alt2_y
      END
    END
    OUTER_SPRINT $~%are%~(~region~ ~%num_regions%~) ~%buffer%~

    // setting up vertices
    OUTER_SET prev_value = 0
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = IS_AN_INT $vertex(~%idx%~) ? $vertex(~%idx%~) : prev_value
      OUTER_SET $~%are%~(~region~ ~%num_regions%~ ~vertex~ ~%idx%~) = value
      OUTER_SET prev_value = value
    END
    OUTER_SET $~%are%~(~region~ ~%num_regions%~ ~vertex~) = num_vertices

    OUTER_SET $~%are%~(~region~) += 1
    OUTER_SET index = num_regions
  END
END

/**
 * Action and patch function that alters attributes of an existing region structure on the ARE handle.
 *
 * INT_VAR region_index       Index of the region structure to patch. Omit if you specify the region structure by name.
 * INT_VAR type               New region type (0=proximity trigger, 1=info point, 2=travel region). (Default: no change)
 * INT_VAR cursor_idx         New cursor index (CURSORS.BAM). (Default: no change)
 * INT_VAR flags              New region flags. (Default: no change)
 * INT_VAR info_point_strref  New strref of information text (for info points). (Default: no change)
 * INT_VAR trap_detect        New trap detection difficulty (%). (Default: no change)
 * INT_VAR trap_remove        New trap removal difficulty (%). (Default: no change)
 * INT_VAR trap_active        New value for whether the region is trapped. (Default: no change)
 * INT_VAR trap_status        New value for whether the region trap has been detected. (Default: no change)
 * INT_VAR loc_x              New X coordinate of the trap launch location. (Default: no change)
 * INT_VAR loc_y              New Y coordinate of the trap launch location. (Default: no change)
 * INT_VAR alt_x              New X coordinate of the alternative use point. (IWD2: X coordinate of the override use point.) (Default: no change)
 * INT_VAR alt_y              New Y coordinate of the alternative use point. (IWD2: Y coordinate of the override use point.) (Default: no change)
 * INT_VAR alt2_x             (IWD2) New X coordinate of the alternative use point. (Default: no change)
 * INT_VAR alt2_y             (IWD2) New Y coordinate of the alternative use point. (Default: no change)
 * INT_VAR talk_loc_x         (PST/PSTEE) New X coordinate of the talk location. (Default: no change)
 * INT_VAR talk_loc_y         (PST/PSTEE) New Y coordinate of the talk location. (Default: no change)
 * INT_VAR speaker_strref     (PST/PSTEE) New strref of the speaker name. (Default: no change)
 * INT_VAR num_vertices       New number of region vertices. If this parameter is specified then the current region vertices are updated
 *                            with the specified vertex definitions. (Default: no change)
 * INT_VAR vertex_0, ...      Array "vertex" with "num_vertices" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                            Alternate notation: $vertex("0"), ...
 *                            Skip entries or assign the constant "A7_ARE_NO_CHANGE" to keep the original vertex value.
 *                            Skipping definitions or using the constant for non-existing vertices will trigger an error.
 *                            This array is only considered if "num_vertices" is defined.
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR region_name        Name of the region structure to patch. Omit if you specify the region structure by index.
 * STR_VAR name               New name of the region. May not be longer than 32 characters. (Default: no change)
 * STR_VAR destination_area   New resref of the destination area (for travel regions). (Default: no change)
 * STR_VAR destination_name   New entrance name in the destination area (for travel regions). (Default: no change)
 * STR_VAR key_resref         New resref of a key item. (Default: no change)
 * STR_VAR script_resref      New resref of the region script. (Default: no change)
 * STR_VAR sound_resref       (PST/PSTEE) New resref of an associated sound. (Default: no change)
 * STR_VAR dialog_resref      (PST/PSTEE) New resref of a dialog file. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_region
INT_VAR
  region_index = "-1"
  type = A7_ARE_NO_CHANGE
  cursor_idx = A7_ARE_NO_CHANGE
  flags = A7_ARE_NO_CHANGE
  info_point_strref = A7_ARE_NO_CHANGE
  trap_detect = A7_ARE_NO_CHANGE
  trap_remove = A7_ARE_NO_CHANGE
  trap_active = A7_ARE_NO_CHANGE
  trap_status = A7_ARE_NO_CHANGE
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  alt_x = A7_ARE_NO_CHANGE
  alt_y = A7_ARE_NO_CHANGE
  alt2_x = A7_ARE_NO_CHANGE
  alt2_y = A7_ARE_NO_CHANGE
  talk_loc_x = A7_ARE_NO_CHANGE
  talk_loc_y = A7_ARE_NO_CHANGE
  speaker_strref = A7_ARE_NO_CHANGE
  num_vertices = A7_ARE_NO_CHANGE
  // vertex_0 = x | (y << 16) ...
  silent = 0
STR_VAR
  are = ~are~
  region_name = ~~
  name = ~?~
  destination_area = ~?~
  destination_name = ~?~
  key_resref = ~?~
  script_resref = ~?~
  sound_resref = ~?~
  dialog_resref = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = region_index silent STR_VAR are type = ~region~ struct_name = EVAL ~%region_name%~ RET success region_index = index END
  END

  // validating names
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~name~ ~destination_name~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 32) BEGIN
        LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string RET string = substring END
        OUTER_SPRINT EVAL ~%param%~ ~%string%~
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" is too long. Removing excess characters.~
        END
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~destination_area~ ~key_resref~ ~script_resref~ ~sound_resref~ ~dialog_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating vertex array
  ACTION_IF (success && num_vertices != A7_ARE_NO_CHANGE) BEGIN
    OUTER_SET num_vertices_old = $~%are%~(~region~ ~%region_index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = VARIABLE_IS_SET $vertex(~%idx%~) ? $vertex(~%idx%~) : A7_ARE_NO_CHANGE
      ACTION_IF (idx >= num_vertices_old && value == A7_ARE_NO_CHANGE) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: Not enough vertex entries defined (expected: %num_vertices%, found: %idx%)~
        END
        OUTER_SET idx = num_vertices
      END ELSE ACTION_IF (value == A7_ARE_NO_CHANGE) BEGIN
        // resolving placeholder constant
        OUTER_SET $vertex(~%idx%~) = $~%are%~(~region~ ~%region_index%~ ~vertex~ ~%idx%~)
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~region~ ~%region_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~region~ ~%region_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (type != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 type END
      PATCH_IF (num_vertices != A7_ARE_NO_CHANGE) BEGIN
        LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices STR_VAR array = ~vertex~ RET min_x max_x min_y max_y END
        WRITE_SHORT 0x22 min_x
        WRITE_SHORT 0x24 min_y
        WRITE_SHORT 0x26 max_x
        WRITE_SHORT 0x28 max_y
        WRITE_SHORT 0x2a num_vertices
      END
      PATCH_IF (cursor_idx != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x34 cursor_idx END
      PATCH_IF (NOT ~%destination_area%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x38 ~%destination_area%~ (8) END
      PATCH_IF (NOT ~%destination_name%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x40 ~%destination_name%~ (32) END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x60 flags END
      PATCH_IF (info_point_strref != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x64 info_point_strref END
      PATCH_IF (trap_detect != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x68 trap_detect END
      PATCH_IF (trap_remove != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x6a trap_remove END
      PATCH_IF (trap_active != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x6c (trap_active != 0) END
      PATCH_IF (trap_status != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x6e (trap_status != 0) END
      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x70 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x72 loc_y END
      PATCH_IF (NOT ~%key_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x74 ~%key_resref%~ (8) END
      PATCH_IF (NOT ~%script_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x7c ~%script_resref%~ (8) END
      PATCH_IF (alt_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x84 alt_x END
      PATCH_IF (alt_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x86 alt_y END
      PATCH_IF (is_v1 && (is_pst || is_pstee)) BEGIN
        PATCH_IF (NOT ~%sound_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0xac ~%sound_resref%~ (8) END
        PATCH_IF (talk_loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xb4 talk_loc_x END
        PATCH_IF (talk_loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xb6 talk_loc_y END
        PATCH_IF (speaker_strref != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0xb8 speaker_strref END
        PATCH_IF (NOT ~%dialog_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0xbc ~%dialog_resref%~ (8) END
      END ELSE PATCH_IF (NOT is_v1) BEGIN
        PATCH_IF (alt2_x != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x88 alt2_x END
        PATCH_IF (alt2_y != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x8c alt2_y END
      END
    END
    OUTER_SPRINT $~%are%~(~region~ ~%region_index%~) ~%buffer%~

    ACTION_IF (num_vertices != A7_ARE_NO_CHANGE) BEGIN
      // patching vertices
      OUTER_SET prev_value = 0
      OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
        OUTER_SET value = IS_AN_INT $vertex(~%idx%~) ? $vertex(~%idx%~) : prev_value
        OUTER_SET $~%are%~(~region~ ~%region_index%~ ~vertex~ ~%idx%~) = value
        OUTER_SET prev_value = value
      END
      OUTER_SET $~%are%~(~region~ ~%region_index%~ ~vertex~) = num_vertices
    END

  END
END

/**
 * Action and patch function that removes an existing region structure from the ARE handle.
 *
 * INT_VAR region_index   Index of the region structure to remove. Omit if you specify the region structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR region_name    Name of the region structure to remove. Omit if you specify the region structure by index.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_region
INT_VAR
  region_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  region_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = region_index silent STR_VAR are type = ~region~ struct_name = EVAL ~%region_name%~ RET success region_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_regions = $~%are%~(~region~)
    OUTER_FOR (idx = region_index + 1; idx < num_regions; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~region~ ~%prev_idx%~) $~%are%~(~region~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~region~ ~%prev_idx%~ ~name~) $~%are%~(~region~ ~%idx%~ ~name~)

      // vertex list
      OUTER_SET num_vertices = $~%are%~(~region~ ~%idx%~ ~vertex~)
      OUTER_FOR (idx2 = 0; idx2 < num_vertices; ++idx2) BEGIN
        OUTER_SET $~%are%~(~region~ ~%prev_idx%~ ~vertex~ ~%idx2%~) = $~%are%~(~region~ ~%idx%~ ~vertex~ ~%idx2%~)
      END
      OUTER_SET $~%are%~(~region~ ~%prev_idx%~ ~vertex~) = num_vertices
    END
    OUTER_SET $~%are%~(~region~) = num_regions - 1
  END
END

/**
 * Action and patch function that moves the position of a region on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR region_index   Index of the region structure to move. Omit if you specify the region structure by name.
 * INT_VAR x              Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y              Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR region_name    Name of the region structure to move. Omit if you specify the region structure by index.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_region
INT_VAR
  region_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
  region_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = region_index silent STR_VAR are type = ~region~ struct_name = EVAL ~%region_name%~ RET success region_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~region~ ~%region_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x22 (THIS + x)
      WRITE_SHORT 0x24 (THIS + y)
      WRITE_SHORT 0x26 (THIS + x)
      WRITE_SHORT 0x28 (THIS + y)
      WRITE_SHORT 0x84 (THIS + x)
      WRITE_SHORT 0x86 (THIS + y)
      PATCH_IF (is_v1 && (is_pst || is_pstee)) BEGIN
        WRITE_SHORT 0xb4 (THIS + x)
        WRITE_SHORT 0xb6 (THIS + y)
      END ELSE PATCH_IF (NOT is_v1) BEGIN
        WRITE_LONG 0x88 (THIS + x)
        WRITE_LONG 0x8c (THIS + y)
      END
    END
    OUTER_SPRINT $~%are%~(~region~ ~%region_index%~) ~%buffer%~

    // moving vertices
    OUTER_SET num_vertices = $~%are%~(~region~ ~%region_index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = $~%are%~(~region~ ~%region_index%~ ~vertex~ ~%idx%~)
      OUTER_SET vx = (value BLSL 16) BASR 16
      OUTER_SET vx += x
      OUTER_SET vy = value BASR 16
      OUTER_SET vy += y
      OUTER_SET $~%are%~(~region~ ~%region_index%~ ~vertex~ ~%idx%~) = (vx & 0xffff) | (vy << 16)
    END
  END
END

/**
 * Action and patch function that scales a region polygon on the ARE handle by a specified factor in either direction.
 *
 * INT_VAR region_index   Index of the region structure to scale. Omit if you specify the region structure by name.
 * INT_VAR scale_x        Indicates whether to scale horizontally. (Default: 1)
 * INT_VAR scale_y        Indicates whether to scale vertically. (Default: 1)
 * INT_VAR numerator      Numerator (top value of a fraction) of the scaling factor. (Default: 1)
 *                        Note: A negative fractional value will mirror the polygon vertex coordinates around the anchor point.
 * INT_VAR denominator    Denominator (bottom value of a fraction) of the scaling factor. Must not be 0. (Default: 1)
 *                        Note: A negative fractional value will mirror the polygon vertex coordinates around the anchor point.
 * INT_VAR x              If "custom" anchor is specified then this value defines the absolute x coordinate of the anchor point. (Default: 0)
 * INT_VAR y              If "custom" anchor is specified then this value defines the absolute y coordinate of the anchor point. (Default: 0)
 * INT_VAR polygon_only   Specify 1 to scale only the region polygon vertices. Specify 0 to scale location coordinates as well. (Default: 1)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR region_name    Name of the region structure to remove. Omit if you specify the region structure by index.
 * STR_VAR anchor         Anchor point for the scaling operation. Relative movement of the vertices is centered on this position. (Default: "origin")
 *                        Supported anchor points:
 *                        - origin:                 Uses absolute coordinates (0,0) as anchor point
 *                        - custom:                 Uses parameters x and y as anchor point coordinates
 *                        - relative_top_left:      Uses top-left bounding box coordinates as anchor point
 *                        - relative_top_center:    Uses top-horizontal center bounding box coordinates as anchor point
 *                        - relative_top_right:     Uses top-right bounding box coordinates as anchor point
 *                        - relative_center_left:   Uses vertical center-left bounding box coordinates as anchor point
 *                        - relative_center_right:  Uses vertical center-right bounding box coordinates as anchor point
 *                        - relative_bottom_left:   Uses bottom-left bounding box coordinates as anchor point
 *                        - relative_bottom_center: Uses bottom-horizontal center bounding box coordinates as anchor point
 *                        - relative_bottom_right:  Uses bottom-right bounding box coordinates as anchor point
 *                        - relative_center:        Uses the (horizontal and vertical) center of the bounding box coordinates as anchor point
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_scale_region
INT_VAR
  region_index = "-1"
  scale_x = 1
  scale_y = 1
  numerator = 1
  denominator = 1
  x = 0
  y = 0
  polygon_only = 1
  silent = 0
STR_VAR
  are = ~are~
  region_name = ~~
  anchor = ~origin~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = region_index silent STR_VAR are type = ~region~ struct_name = EVAL ~%region_name%~ RET success region_index = index END
  END

  ACTION_IF (success && denominator == 0) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Denominator of the scaling factor cannot be 0.~
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~region~ ~%region_index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_SSHORT 0x22 min_x
      READ_SSHORT 0x24 min_y
      READ_SSHORT 0x26 max_x
      READ_SSHORT 0x28 max_y
    END

    LAF a7#__get_scale_anchor
      INT_VAR min_x min_y max_x max_y x y silent
      STR_VAR anchor
      RET success x y
    END
  END

  ACTION_IF (success && numerator != denominator) BEGIN
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      // patching bounding box
      PATCH_IF (scale_x) BEGIN
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x22 anchor = x numerator denominator RET value END
        WRITE_SHORT 0x22 value
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x26 anchor = x numerator denominator RET value END
        WRITE_SHORT 0x26 value
      END
      PATCH_IF (scale_y) BEGIN
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x24 anchor = y numerator denominator RET value END
        WRITE_SHORT 0x24 value
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x28 anchor = y numerator denominator RET value END
        WRITE_SHORT 0x28 value
      END

      // patching locations
      PATCH_IF (NOT polygon_only) BEGIN
        PATCH_IF (scale_x) BEGIN
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x70 anchor = x numerator denominator RET value END
          WRITE_SHORT 0x70 value
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x84 anchor = x numerator denominator RET value END
          WRITE_SHORT 0x84 value
          PATCH_IF (is_v1 && (is_pst || is_pstee)) BEGIN
            LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0xb4 anchor = x numerator denominator RET value END
            WRITE_SHORT 0xb4 value
          END ELSE PATCH_IF (NOT is_v1) BEGIN
            LPF a7#__scale_coordinate INT_VAR value = SLONG_AT 0x88 anchor = x numerator denominator RET value END
            WRITE_LONG 0x88 value
          END
        END

        PATCH_IF (scale_y) BEGIN
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x72 anchor = y numerator denominator RET value END
          WRITE_SHORT 0x72 value
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x86 anchor = y numerator denominator RET value END
          WRITE_SHORT 0x86 value
          PATCH_IF (is_v1 && (is_pst || is_pstee)) BEGIN
            LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0xb6 anchor = y numerator denominator RET value END
            WRITE_SHORT 0xb6 value
          END ELSE PATCH_IF (NOT is_v1) BEGIN
            LPF a7#__scale_coordinate INT_VAR value = SLONG_AT 0x8c anchor = y numerator denominator RET value END
            WRITE_LONG 0x8c value
          END
        END
      END
    END
    OUTER_SPRINT $~%are%~(~region~ ~%region_index%~) ~%buffer%~

    // patching vertices
    OUTER_SET num_vertices = $~%are%~(~region~ ~%region_index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = $~%are%~(~region~ ~%region_index%~ ~vertex~ ~%idx%~)
      OUTER_SET vx = (value BLSL 16) BASR 16
      OUTER_SET vy = value BASR 16
      ACTION_IF (scale_x) BEGIN
        LAF a7#__scale_coordinate INT_VAR value = vx anchor = x numerator denominator RET vx = value END
      END
      ACTION_IF (scale_y) BEGIN
        LAF a7#__scale_coordinate INT_VAR value = vy anchor = y numerator denominator RET vy = value END
      END
      OUTER_SET $~%are%~(~region~ ~%region_index%~ ~vertex~ ~%idx%~) = (vx & 0xffff) | (vy << 16)
    END
  END
END

/**
 * Action and patch function that adds a new spawn point to the ARE handle.
 *
 * INT_VAR loc_x              X coordinate of the spawn point. (Default: 0)
 * INT_VAR loc_y              Y coordinate of the spawn point. (Default: 0)
 * INT_VAR spawn_num          Count of spawn creatures. (Default: 0)
 * INT_VAR difficulty         Base number of creatures to spawn. (Default: 0)
 *                            Formula: # spawns = (delay * avg. party level) / creature power. Results are rounded down.
 * INT_VAR delay              Delay between spawning, in seconds. (Default: 10)
 * INT_VAR method             Spawn method. (Default: 0)
 * INT_VAR duration           Creature removal timer, in seconds. Specify -1 to avoid removal. (Default: 1000)
 * INT_VAR wander_distance    Movement restriction distance. (Default: 1000)
 * INT_VAR follow_distance    Movement restriction distance (move to object). (Default: 1000)
 * INT_VAR max_num            Max. number of creatures to spawn. (Default: 0)
 * INT_VAR active             Whether the spawn point is active. (Default: 1)
 * INT_VAR schedule           Hourly appearance schedule. (Default: always active)
 * INT_VAR day_prob           Daytime probability. (Default: 100)
 * INT_VAR night_prob         Nighttime probability. (Default: 100)
 * INT_VAR spawn_freq         (EE) Spawn frequency, in seconds. (Default: 0)
 * INT_VAR countdown          (EE) Spawn countdown. (Default: 0)
 * INT_VAR weight0, ...       Weight of the spawn creatures. Range: weight0 ... weight9. (Default: 0)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name               Name of the spawn point. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR cre_resref0, ...   Resref of the creature to spawn. Range: cre_resref0 ... cre_resref9. (Default: empty string)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET index                  Returns the index of the added spawn point structure if successful, -1 otherwise
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_spawnpoint
INT_VAR
  loc_x = 0
  loc_y = 0
  spawn_num = 0
  difficulty = 0
  delay = 10
  method = 0
  duration = 1000
  wander_distance = 1000
  follow_distance = 1000
  max_num = 0
  active = 1
  schedule = 0x00ffffff
  day_prob = 100
  night_prob = 100
  spawn_freq = 0
  countdown = 0
  weight0 = 0
  weight1 = 0
  weight2 = 0
  weight3 = 0
  weight4 = 0
  weight5 = 0
  weight6 = 0
  weight7 = 0
  weight8 = 0
  weight9 = 0
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  cre_resref0 = ~~
  cre_resref1 = ~~
  cre_resref2 = ~~
  cre_resref3 = ~~
  cre_resref4 = ~~
  cre_resref5 = ~~
  cre_resref6 = ~~
  cre_resref7 = ~~
  cre_resref8 = ~~
  cre_resref9 = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_spawns = $~%are%~(~spawnpoint~)

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    OUTER_FOR (i = 0; i < 10; ++i) BEGIN
      OUTER_SPRINT param ~cre_resref%i%~
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~spawnpoint~ ~%num_spawns%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 200

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 loc_x
      WRITE_SHORT 0x22 loc_y
      FOR (i = 0; i < 10; ++i) BEGIN
        SPRINT resref EVAL ~%cre_resref%i%%~
        WRITE_ASCIIE (0x24 + i * 8) ~%resref%~ (8)
      END
      WRITE_SHORT 0x74 spawn_num
      WRITE_SHORT 0x76 difficulty
      WRITE_SHORT 0x78 delay
      WRITE_SHORT 0x7a method
      WRITE_LONG 0x7c duration
      WRITE_SHORT 0x80 wander_distance
      WRITE_SHORT 0x82 follow_distance
      WRITE_SHORT 0x84 max_num
      WRITE_SHORT 0x86 (active != 0)
      WRITE_LONG 0x88 schedule
      WRITE_SHORT 0x8c day_prob
      WRITE_SHORT 0x8e night_prob
      PATCH_IF (is_v1 && is_ee) BEGIN
        WRITE_LONG 0x90 spawn_freq
        WRITE_LONG 0x94 countdown
        FOR (i = 0; i < 10; ++i) BEGIN
          SET value = EVAL ~weight%i%~
          WRITE_BYTE (0x98 + i) value
        END
      END
    END
    OUTER_SPRINT $~%are%~(~spawnpoint~ ~%num_spawns%~) ~%buffer%~
    OUTER_SET $~%are%~(~spawnpoint~) += 1
    OUTER_SET index = num_spawns
  END
END

/**
 * Action and patch function that alters attributes of an existing spawn point structure on the ARE handle.
 *
 * INT_VAR spawnpoint_index   Index of the spawn point structure to patch. Omit if you specify the spawn point structure by name.
 * INT_VAR loc_x              New X coordinate of the spawn point. (Default: no change)
 * INT_VAR loc_y              New Y coordinate of the spawn point. (Default: no change)
 * INT_VAR spawn_num          New count of spawn creatures. (Default: no change)
 * INT_VAR difficulty         New base number of creatures to spawn. (Default: no change)
 *                            Formula: # spawns = (delay * avg. party level) / creature power. Results are rounded down.
 * INT_VAR delay              New delay between spawning, in seconds. (Default: no change)
 * INT_VAR method             New spawn method. (Default: no change)
 * INT_VAR duration           New creature removal timer, in seconds. Specify -1 to avoid removal. (Default: no change)
 * INT_VAR wander_distance    New movement restriction distance. (Default: no change)
 * INT_VAR follow_distance    New movement restriction distance (move to object). (Default: no change)
 * INT_VAR max_num            New max. number of creatures to spawn. (Default: no change)
 * INT_VAR active             New value for whether the spawn point is active. (Default: no change)
 * INT_VAR schedule           New hourly appearance schedule. (Default: no change)
 * INT_VAR day_prob           New daytime probability. (Default: no change)
 * INT_VAR night_prob         New nighttime probability. (Default: no change)
 * INT_VAR spawn_freq         (EE) New spawn frequency, in seconds. (Default: no change)
 * INT_VAR countdown          (EE) New spawn countdown. (Default: no change)
 * INT_VAR weight0, ...       New weight of the spawn creatures. Range: weight0 ... weight9. (Default: no change)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR spawnpoint_name    Name of the spawn point structure to patch. Omit if you specify the spawn point structure by index.
 * STR_VAR name               New name of the spawn point. May not be longer than 32 characters. (Default: no change)
 * STR_VAR cre_resref0, ...   New resref of the creature to spawn. Range: cre_resref0 ... cre_resref9. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_spawnpoint
INT_VAR
  spawnpoint_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  spawn_num = A7_ARE_NO_CHANGE
  difficulty = A7_ARE_NO_CHANGE
  delay = A7_ARE_NO_CHANGE
  method = A7_ARE_NO_CHANGE
  duration = A7_ARE_NO_CHANGE
  wander_distance = A7_ARE_NO_CHANGE
  follow_distance = A7_ARE_NO_CHANGE
  max_num = A7_ARE_NO_CHANGE
  active = A7_ARE_NO_CHANGE
  schedule = A7_ARE_NO_CHANGE
  day_prob = A7_ARE_NO_CHANGE
  night_prob = A7_ARE_NO_CHANGE
  spawn_freq = A7_ARE_NO_CHANGE
  countdown = A7_ARE_NO_CHANGE
  weight0 = A7_ARE_NO_CHANGE
  weight1 = A7_ARE_NO_CHANGE
  weight2 = A7_ARE_NO_CHANGE
  weight3 = A7_ARE_NO_CHANGE
  weight4 = A7_ARE_NO_CHANGE
  weight5 = A7_ARE_NO_CHANGE
  weight6 = A7_ARE_NO_CHANGE
  weight7 = A7_ARE_NO_CHANGE
  weight8 = A7_ARE_NO_CHANGE
  weight9 = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  spawnpoint_name = ~~
  name = ~?~
  cre_resref0 = ~?~
  cre_resref1 = ~?~
  cre_resref2 = ~?~
  cre_resref3 = ~?~
  cre_resref4 = ~?~
  cre_resref5 = ~?~
  cre_resref6 = ~?~
  cre_resref7 = ~?~
  cre_resref8 = ~?~
  cre_resref9 = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = spawnpoint_index silent STR_VAR are type = ~spawnpoint~ struct_name = EVAL ~%spawnpoint_name%~ RET success spawnpoint_index = index END
  END

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    OUTER_FOR (i = 0; i < 10; ++i) BEGIN
      OUTER_SPRINT param ~cre_resref%i%~
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~spawnpoint~ ~%spawnpoint_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~spawnpoint~ ~%spawnpoint_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x22 loc_y END
      FOR (i = 0; i < 10; ++i) BEGIN
        SPRINT resref EVAL ~%cre_resref%i%%~
        PATCH_IF (NOT ~%resref%~ STR_EQ ~?~) BEGIN  WRITE_ASCIIE (0x24 + i * 8) ~%resref%~ (8) END
      END
      PATCH_IF (spawn_num != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x74 spawn_num END
      PATCH_IF (difficulty != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x76 difficulty END
      PATCH_IF (delay != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x78 delay END
      PATCH_IF (method != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x7a method END
      PATCH_IF (duration != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x7c duration END
      PATCH_IF (wander_distance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x80 wander_distance END
      PATCH_IF (follow_distance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x82 follow_distance END
      PATCH_IF (max_num != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x84 max_num END
      PATCH_IF (active != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x86 (active != 0) END
      PATCH_IF (schedule != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x88 schedule END
      PATCH_IF (day_prob != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x8c day_prob END
      PATCH_IF (night_prob != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x8e night_prob END
      PATCH_IF (is_v1 && is_ee) BEGIN
        PATCH_IF (spawn_freq != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x90 spawn_freq END
        PATCH_IF (countdown != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x94 countdown END
        FOR (i = 0; i < 10; ++i) BEGIN
          SET value = EVAL ~weight%i%~
          PATCH_IF (value != A7_ARE_NO_CHANGE) BEGIN WRITE_BYTE (0x98 + i) value END
        END
      END
    END
    OUTER_SPRINT $~%are%~(~spawnpoint~ ~%spawnpoint_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing spawn point structure from the ARE handle.
 *
 * INT_VAR spawnpoint_index   Index of the spawn point structure to remove. Omit if you specify the spawn point structure by name.
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR spawnpoint_name    Name of the spawn point structure to remove. Omit if you specify the spawn point structure by index.
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_spawnpoint
INT_VAR
  spawnpoint_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  spawnpoint_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = spawnpoint_index silent STR_VAR are type = ~spawnpoint~ struct_name = EVAL ~%spawnpoint_name%~ RET success spawnpoint_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_spawnpoints = $~%are%~(~spawnpoint~)
    OUTER_FOR (idx = spawnpoint_index + 1; idx < num_spawnpoints; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~spawnpoint~ ~%prev_idx%~) $~%are%~(~spawnpoint~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~spawnpoint~ ~%prev_idx%~ ~name~) $~%are%~(~spawnpoint~ ~%idx%~ ~name~)
    END
    OUTER_SET $~%are%~(~spawnpoint~) = num_spawnpoints - 1
  END
END

/**
 * Action and patch function that moves the position of a spawn point on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR spawnpoint_index   Index of the spawn point structure to move. Omit if you specify the spawn point structure by name.
 * INT_VAR x                  Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y                  Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR spawnpoint_name    Name of the spawn point structure to move. Omit if you specify the spawn point structure by index.
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_spawnpoint
INT_VAR
  spawnpoint_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
  spawnpoint_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = spawnpoint_index silent STR_VAR are type = ~spawnpoint~ struct_name = EVAL ~%spawnpoint_name%~ RET success spawnpoint_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~spawnpoint~ ~%spawnpoint_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x20 (THIS + x)
      WRITE_SHORT 0x22 (THIS + y)
    END
    OUTER_SPRINT $~%are%~(~spawnpoint~ ~%spawnpoint_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new entrance to the ARE handle.
 *
 * INT_VAR loc_x          X coordinate of the entrance. (Default: 0)
 * INT_VAR loc_y          Y coordinate of the entrance. (Default: 0)
 * INT_VAR orientation    The facing direction. (0=South, 4=West, 8=North, 12=East). (Default: 0)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the entrance. May not be longer than 32 characters. (Default: empty string)
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET index              Returns the index of the added entrance structure if successful, -1 otherwise
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_entrance
INT_VAR
  loc_x = 0
  loc_y = 0
  orientation = 0
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET num_entrances = $~%are%~(~entrance~)

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~entrance~ ~%num_entrances%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 104

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 loc_x
      WRITE_SHORT 0x22 loc_y
      WRITE_SHORT 0x24 orientation
    END
    OUTER_SPRINT $~%are%~(~entrance~ ~%num_entrances%~) ~%buffer%~
    OUTER_SET $~%are%~(~entrance~) += 1
    OUTER_SET index = num_entrances
  END
END

/**
 * Action and patch function that alters attributes of an existing entrance structure on the ARE handle.
 *
 * INT_VAR entrance_index   Index of the entrance structure to patch. Omit if you specify the entrance structure by name.
 * INT_VAR loc_x            New X coordinate of the entrance. (Default: no change)
 * INT_VAR loc_y            New Y coordinate of the entrance. (Default: no change)
 * INT_VAR orientation      New facing direction. (0=South, 4=West, 8=North, 12=East). (Default: no change)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR entrance_name    Name of the entrance structure to patch. Omit if you specify the entrance structure by index.
 * STR_VAR name             New name of the entrance. May not be longer than 32 characters. (Default: no change)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_entrance
INT_VAR
  entrance_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  orientation = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  entrance_name = ~~
  name = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = entrance_index silent STR_VAR are type = ~entrance~ struct_name = EVAL ~%entrance_name%~ RET success entrance_index = index END
  END

  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~entrance~ ~%entrance_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~entrance~ ~%entrance_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x22 loc_y END
      PATCH_IF (orientation != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x24 orientation END
    END
    OUTER_SPRINT $~%are%~(~entrance~ ~%entrance_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing entrance structure from the ARE handle.
 *
 * INT_VAR entrance_index   Index of the entrance structure to remove. Omit if you specify the entrance structure by name.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR entrance_name    Name of the entrance structure to remove. Omit if you specify the entrance structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_entrance
INT_VAR
  entrance_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  entrance_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = entrance_index silent STR_VAR are type = ~entrance~ struct_name = EVAL ~%entrance_name%~ RET success entrance_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_entrances = $~%are%~(~entrance~)
    OUTER_FOR (idx = entrance_index + 1; idx < num_entrances; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~entrance~ ~%prev_idx%~) $~%are%~(~entrance~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~entrance~ ~%prev_idx%~ ~name~) $~%are%~(~entrance~ ~%idx%~ ~name~)
    END
    OUTER_SET $~%are%~(~entrance~) = num_entrances - 1
  END
END

/**
 * Action and patch function that moves the position of an entrance on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR entrance_index   Index of the entrance structure to move. Omit if you specify the entrance structure by name.
 * INT_VAR x                Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y                Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR turn             Amount of units to advance the orientation. A full turn consists of 16 units. Specify positive values to turn in
 *                          clockwise direction and negative values to turn in counter-clockwise direction.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR entrance_name    Name of the entrance structure to move. Omit if you specify the entrance structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_entrance
INT_VAR
  entrance_index = "-1"
  x = 0
  y = 0
  turn = 0
  silent = 0
STR_VAR
  are = ~are~
  entrance_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = entrance_index silent STR_VAR are type = ~entrance~ struct_name = EVAL ~%entrance_name%~ RET success entrance_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0 || turn != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~entrance~ ~%entrance_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x20 (THIS + x)
      WRITE_SHORT 0x22 (THIS + y)
      WRITE_SHORT 0x24 ((((THIS + turn) MODULO 16) + 16) MODULO 16)
    END
    OUTER_SPRINT $~%are%~(~entrance~ ~%entrance_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new container to the ARE handle.
 *
 * INT_VAR loc_x              X coordinate of container access point. (Default: 0)
 * INT_VAR loc_y              Y coordinate of container access point. (Default: 0)
 * INT_VAR type               Container type. (Default: 0)
 * INT_VAR lock_diff          Lock difficulty. (Default: 100)
 * INT_VAR flags              Container flags. (Default: 0)
 * INT_VAR trap_detect        Trap detection difficulty. (Default: 0)
 * INT_VAR trap_remove_diff   Trap removal difficulty. (Default: 100)
 * INT_VAR trap_active        Whether container is trapped. (Default: 0)
 * INT_VAR trap_status        Whether container trap has been detected. (Default: 0)
 * INT_VAR trap_loc_x         Trap launch X coordinate. (Default: 0)
 * INT_VAR trap_loc_y         Trap launch Y coordinate. (Default: 0)
 * INT_VAR trigger_range      Activation range. (Default: 0)
 * INT_VAR break_difficulty   Lock break difficulty. (Default: 0)
 * INT_VAR lockpick_strref    Lockpick strref. (Default: -1)
 * INT_VAR num_items          Number of item definitions to add. (Default: 0)
 * INT_VAR num_vertices       Number of polygon vertices to add. (Default: 0)
 * INT_VAR vertex_0, ...      Array "vertex" with "num_vertices" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                            Alternate notation: $vertex("0"), ...
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name               Name of the container. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR owner_name         Name of the container owner (script name). May not be longer than 32 characters. (Default: empty string)
 * STR_VAR trap_script        Resref of the trap script. (Default: empty string)
 * STR_VAR key_resref         Resref of the "key" item. (Default: empty string)
 * STR_VAR item_0, ...        Array "item" with "num_items" entries. An item entry consists of:
 *                            - STR_VAR item_X: The ITM resref itself (required)
 *                            - INT_VAR item_X_charge1: Item charges added to "item_X_charge1", "item_X_charge2", and "item_X_charge3". (Default: 0)
 *                            - INT_VAR item_X_flags: Item flags. (Default: 0)
 *                            - INT_VAR item_X_expiry: Item expiration time. (Not needed for item definitions outside of saved games.) (Default: 0)
 *                            Alternate notation: $item("0"), $item("0" "charge1"), $item("0" "flags"), ...
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET index                  Returns the index of the added container structure if successful, -1 otherwise
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_container
INT_VAR
  loc_x = 0
  loc_y = 0
  type = 0
  lock_diff = 100
  flags = 0
  trap_detect = 0
  trap_remove_diff = 100
  trap_active = 0
  trap_status = 0
  trap_loc_x = 0
  trap_loc_y = 0
  trigger_range = 0
  break_difficulty = 0
  lockpick_strref = "-1"
  num_items = 0
  num_vertices = 0
  // item_0_expiry = 0 ...
  // item_0_charge1 = 0 ...
  // item_0_charge2 = 0 ...
  // item_0_charge3 = 0 ...
  // item_0_flags = 0 ...
  // vertex_0 = x | (y << 16) ...
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  owner_name = ~~
  trap_script = ~~
  key_resref = ~~
  // item_0 = ~~ ...
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET index = "-1"
  OUTER_SET num_containers = $~%are%~(~container~)

  // validating names
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~name~ ~owner_name~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 32) BEGIN
        LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string RET string = substring END
        OUTER_SPRINT EVAL ~%param%~ ~%string%~
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" is too long. Removing excess characters.~
        END
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~trap_script~ ~key_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating item array
  ACTION_IF (success) BEGIN
    OUTER_SET num_items = num_items < 0 ? 0 : num_items
    LAF a7#__are_validate_array INT_VAR count = num_items STR_VAR name = ~item~ RET result END
    ACTION_IF (result < num_items) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Not enough item entries defined (expected: %num_items%, found: %result%)~
      END
    END
  END

  // validating vertex array
  ACTION_IF (success) BEGIN
    OUTER_SET num_vertices = num_vertices < 0 ? 0 : num_vertices
    LAF a7#__are_validate_array INT_VAR count = num_vertices STR_VAR name = ~vertex~ RET result END
    ACTION_IF (result < num_vertices) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Not enough vertex entries defined (expected: %num_vertices%, found: %result%)~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~container~ ~%num_containers%~ ~name~) ~%name%~
    OUTER_SET $~%are%~(~container~ ~%num_containers%~ ~item~) = 0
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 192

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 loc_x
      WRITE_SHORT 0x22 loc_y
      WRITE_SHORT 0x24 type
      WRITE_SHORT 0x26 lock_diff
      WRITE_LONG 0x28 flags
      WRITE_SHORT 0x2c trap_detect
      WRITE_SHORT 0x2e trap_remove_diff
      WRITE_SHORT 0x30 (trap_active != 0)
      WRITE_SHORT 0x32 (trap_status != 0)
      WRITE_SHORT 0x34 trap_loc_x
      WRITE_SHORT 0x36 trap_loc_y
      LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices STR_VAR array = ~vertex~ RET min_x max_x min_y max_y END
      WRITE_SHORT 0x38 min_x
      WRITE_SHORT 0x3a min_y
      WRITE_SHORT 0x3c max_x
      WRITE_SHORT 0x3e max_y
      WRITE_LONG 0x44 0 // updated below
      WRITE_ASCIIE 0x48 ~%trap_script%~ (8)
      WRITE_SHORT 0x54 num_vertices
      WRITE_SHORT 0x56 trigger_range
      WRITE_ASCIIE 0x58 ~%owner_name%~ (32)
      WRITE_ASCIIE 0x78 ~%key_resref%~ (8)
      WRITE_LONG 0x80 break_difficulty
      WRITE_LONG 0x84 lockpick_strref
    END
    OUTER_SPRINT $~%are%~(~container~ ~%num_containers%~) ~%buffer%~

    // setting up vertices
    OUTER_SET prev_value = 0
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = IS_AN_INT $vertex(~%idx%~) ? $vertex(~%idx%~) : prev_value
      OUTER_SET $~%are%~(~container~ ~%num_containers%~ ~vertex~ ~%idx%~) = value
      OUTER_SET prev_value = value
    END
    OUTER_SET $~%are%~(~container~ ~%num_containers%~ ~vertex~) = num_vertices

    OUTER_SET $~%are%~(~container~) += 1
    OUTER_SET index = num_containers

    // adding items
    OUTER_FOR (idx = 0; success && idx < num_items; ++idx) BEGIN
      OUTER_SPRINT item_resref $item(~%idx%~)
      OUTER_SET charge1 = IS_AN_INT $item(~%idx%~ ~charge1~) ? $item(~%idx%~ ~charge1~) : 0
      OUTER_SET charge2 = IS_AN_INT $item(~%idx%~ ~charge2~) ? $item(~%idx%~ ~charge2~) : 0
      OUTER_SET charge3 = IS_AN_INT $item(~%idx%~ ~charge3~) ? $item(~%idx%~ ~charge3~) : 0
      OUTER_SET flags = IS_AN_INT $item(~%idx%~ ~flags~) ? $item(~%idx%~ ~flags~) : 0
      OUTER_SET expiry = IS_AN_INT $item(~%idx%~ ~expiry~) ? $item(~%idx%~ ~expiry~) : 0
      LAF a7#batch_are_add_container_item
        INT_VAR container_index = index charge1 charge2 charge3 flags expiry
        STR_VAR are item_resref
        RET success
        RET_ARRAY ~%are%~
      END
    END
  END
END

/**
 * Action and patch function that alters attributes of an existing container structure on the ARE handle.
 *
 * INT_VAR container_index    Index of the container structure to patch. Omit if you specify the container structure by name.
 * INT_VAR loc_x              New X coordinate of container access point. (Default: no change)
 * INT_VAR loc_y              New Y coordinate of container access point. (Default: no change)
 * INT_VAR type               New container type. (Default: no change)
 * INT_VAR lock_diff          New lock difficulty. (Default: no change)
 * INT_VAR flags              New container flags. (Default: no change)
 * INT_VAR trap_detect        New trap detection difficulty. (Default: no change)
 * INT_VAR trap_remove_diff   New trap removal difficulty. (Default: no change)
 * INT_VAR trap_active        New value for whether container is trapped. (Default: no change)
 * INT_VAR trap_status        New value for whether container trap has been detected. (Default: no change)
 * INT_VAR trap_loc_x         New trap launch X coordinate. (Default: no change)
 * INT_VAR trap_loc_y         New trap launch Y coordinate. (Default: no change)
 * INT_VAR trigger_range      New activation range. (Default: no change)
 * INT_VAR break_difficulty   New lock break difficulty. (Default: no change)
 * INT_VAR lockpick_strref    New lockpick strref. (Default: no change)
 * INT_VAR num_vertices       New number of polygon vertices. If this parameter is specified then the current container vertices are updated
 *                            with the specified vertex definitions. (Default: no change)
 * INT_VAR vertex_0, ...      Array "vertex" with "num_vertices" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                            Alternate notation: $vertex("0"), ...
 *                            Skip entries or assign the constant "A7_ARE_NO_CHANGE" to keep the original vertex value.
 *                            Skipping definitions or using the constant for non-existing vertices will trigger an error.
 *                            This array is only considered if "num_vertices" is defined.
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR container_name     Name of the container structure to patch. Omit if you specify the container structure by index.
 * STR_VAR name               New name of the container. May not be longer than 32 characters. (Default: no change)
 * STR_VAR owner_name         New name of the container owner (script name). May not be longer than 32 characters. (Default: no change)
 * STR_VAR trap_script        New resref of the trap script. (Default: no change)
 * STR_VAR key_resref         New resref of the "key" item. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_container
INT_VAR
  container_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  type = A7_ARE_NO_CHANGE
  lock_diff = A7_ARE_NO_CHANGE
  flags = A7_ARE_NO_CHANGE
  trap_detect = A7_ARE_NO_CHANGE
  trap_remove_diff = A7_ARE_NO_CHANGE
  trap_active = A7_ARE_NO_CHANGE
  trap_status = A7_ARE_NO_CHANGE
  trap_loc_x = A7_ARE_NO_CHANGE
  trap_loc_y = A7_ARE_NO_CHANGE
  trigger_range = A7_ARE_NO_CHANGE
  break_difficulty = A7_ARE_NO_CHANGE
  lockpick_strref = A7_ARE_NO_CHANGE
  num_vertices = A7_ARE_NO_CHANGE
  // vertex_0 = x | (y << 16) ...
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
  name = ~?~
  owner_name = ~?~
  trap_script = ~?~
  key_resref = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  // validating names
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~name~ ~owner_name~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 32) BEGIN
        LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string RET string = substring END
        OUTER_SPRINT EVAL ~%param%~ ~%string%~
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" is too long. Removing excess characters.~
        END
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~trap_script~ ~key_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating vertex array
  ACTION_IF (success && num_vertices != A7_ARE_NO_CHANGE) BEGIN
    OUTER_SET num_vertices_old = $~%are%~(~container~ ~%container_index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = VARIABLE_IS_SET $vertex(~%idx%~) ? $vertex(~%idx%~) : A7_ARE_NO_CHANGE
      ACTION_IF (idx >= num_vertices_old && value == A7_ARE_NO_CHANGE) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: Not enough vertex entries defined (expected: %num_vertices%, found: %idx%)~
        END
        OUTER_SET idx = num_vertices
      END ELSE ACTION_IF (value == A7_ARE_NO_CHANGE) BEGIN
        // resolving placeholder constant
        OUTER_SET $vertex(~%idx%~) = $~%are%~(~container~ ~%container_index%~ ~vertex~ ~%idx%~)
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~container~ ~%container_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x22 loc_y END
      PATCH_IF (type != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x24 type END
      PATCH_IF (lock_diff != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x26 lock_diff END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x28 flags END
      PATCH_IF (trap_detect != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x2c trap_detect END
      PATCH_IF (trap_remove_diff != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x2e trap_remove_diff END
      PATCH_IF (trap_active != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x30 (trap_active != 0) END
      PATCH_IF (trap_status != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x32 (trap_status != 0) END
      PATCH_IF (trap_loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x34 trap_loc_x END
      PATCH_IF (trap_loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x36 trap_loc_y END
      PATCH_IF (num_vertices != A7_ARE_NO_CHANGE) BEGIN
        LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices STR_VAR array = ~vertex~ RET min_x max_x min_y max_y END
        WRITE_SHORT 0x38 min_x
        WRITE_SHORT 0x3a min_y
        WRITE_SHORT 0x3c max_x
        WRITE_SHORT 0x3e max_y
        WRITE_SHORT 0x54 num_vertices
      END
      PATCH_IF (NOT ~%trap_script%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x48 ~%trap_script%~ (8) END
      PATCH_IF (trigger_range != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x56 trigger_range END
      PATCH_IF (NOT ~%owner_name%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x58 ~%owner_name%~ (32) END
      PATCH_IF (NOT ~%key_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x78 ~%key_resref%~ (8) END
      PATCH_IF (break_difficulty != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x80 break_difficulty END
      PATCH_IF (lockpick_strref != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x84 lockpick_strref END
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~) ~%buffer%~

    ACTION_IF (num_vertices != A7_ARE_NO_CHANGE) BEGIN
      // patching vertices
      OUTER_SET prev_value = 0
      OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
        OUTER_SET value = IS_AN_INT $vertex(~%idx%~) ? $vertex(~%idx%~) : prev_value
        OUTER_SET $~%are%~(~container~ ~%container_index%~ ~vertex~ ~%idx%~) = value
        OUTER_SET prev_value = value
      END
      OUTER_SET $~%are%~(~container~ ~%container_index%~ ~vertex~) = num_vertices
    END
  END
END

/**
 * Action and patch function that removes an existing container structure from the ARE handle.
 *
 * INT_VAR container_index  Index of the container structure to remove. Omit if you specify the container structure by name.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR container_name   Name of the container structure to remove. Omit if you specify the container structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_container
INT_VAR
  container_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_containers = $~%are%~(~container~)
    OUTER_FOR (idx = container_index + 1; idx < num_containers; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~container~ ~%prev_idx%~) $~%are%~(~container~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~container~ ~%prev_idx%~ ~name~) $~%are%~(~container~ ~%idx%~ ~name~)

      // item list
      OUTER_SET num_items = $~%are%~(~container~ ~%idx%~ ~item~)
      OUTER_FOR (idx2 = 0; idx2 < num_items; ++idx2) BEGIN
        OUTER_SPRINT $~%are%~(~container~ ~%prev_idx%~ ~item~ ~%idx2%~) $~%are%~(~container~ ~%idx%~ ~item~ ~%idx2%~)
        OUTER_SPRINT $~%are%~(~container~ ~%prev_idx%~ ~item~ ~%idx2%~ ~resref~) $~%are%~(~container~ ~%idx%~ ~item~ ~%idx2%~ ~resref~)
      END
      OUTER_SET $~%are%~(~container~ ~%prev_idx%~ ~item~) = num_items

      // vertex list
      OUTER_SET num_vertices = $~%are%~(~container~ ~%idx%~ ~vertex~)
      OUTER_FOR (idx2 = 0; idx2 < num_vertices; ++idx2) BEGIN
        OUTER_SET $~%are%~(~container~ ~%prev_idx%~ ~vertex~ ~%idx2%~) = $~%are%~(~container~ ~%idx%~ ~vertex~ ~%idx2%~)
      END
      OUTER_SET $~%are%~(~container~ ~%prev_idx%~ ~vertex~) = num_vertices
    END
    OUTER_SET $~%are%~(~container~) = num_containers - 1
  END
END

/**
 * Action and patch function that moves the position of a container on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR container_index  Index of the container structure to move. Omit if you specify the container structure by name.
 * INT_VAR x                Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y                Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR container_name   Name of the container structure to move. Omit if you specify the container structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_container
INT_VAR
  container_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x20 (THIS + x)
      WRITE_SHORT 0x22 (THIS + y)

      WRITE_SHORT 0x34 (THIS + x)
      WRITE_SHORT 0x36 (THIS + y)

      WRITE_SHORT 0x38 (THIS + x)
      WRITE_SHORT 0x3a (THIS + y)
      WRITE_SHORT 0x3c (THIS + x)
      WRITE_SHORT 0x3e (THIS + y)
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~) ~%buffer%~

    // moving vertices
    OUTER_SET num_vertices = $~%are%~(~container~ ~%container_index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = $~%are%~(~container~ ~%container_index%~ ~vertex~ ~%idx%~)
      OUTER_SET vx = (value BLSL 16) BASR 16
      OUTER_SET vx += x
      OUTER_SET vy = value BASR 16
      OUTER_SET vy += y
      OUTER_SET $~%are%~(~container~ ~%container_index%~ ~vertex~ ~%idx%~) = (vx & 0xffff) | (vy << 16)
    END
  END
END

/**
 * Action and patch function that scales a container polygon on the ARE handle by a specified factor in either direction.
 *
 * INT_VAR container_index  Index of the container structure to scale. Omit if you specify the container structure by name.
 * INT_VAR scale_x          Indicates whether to scale horizontally. (Default: 1)
 * INT_VAR scale_y          Indicates whether to scale vertically. (Default: 1)
 * INT_VAR numerator        Numerator (top value of a fraction) of the scaling factor. (Default: 1)
 *                          Note: A negative fractional value will mirror the polygon vertex coordinates around the anchor point.
 * INT_VAR denominator      Denominator (bottom value of a fraction) of the scaling factor. Must not be 0. (Default: 1)
 *                          Note: A negative fractional value will mirror the polygon vertex coordinates around the anchor point.
 * INT_VAR x                If "custom" anchor is specified then this value defines the absolute x coordinate of the anchor point. (Default: 0)
 * INT_VAR y                If "custom" anchor is specified then this value defines the absolute y coordinate of the anchor point. (Default: 0)
 * INT_VAR polygon_only     Specify 1 to scale only the container polygon vertices. Specify 0 to scale location coordinates as well. (Default: 1)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR container_name   Name of the container structure to remove. Omit if you specify the container structure by index.
 * STR_VAR anchor           Anchor point for the scaling operation. Relative movement of the vertices is centered on this position. (Default: "origin")
 *                          Supported anchor points:
 *                          - origin:                 Uses absolute coordinates (0,0) as anchor point
 *                          - custom:                 Uses parameters x and y as anchor point coordinates
 *                          - relative_top_left:      Uses top-left bounding box coordinates as anchor point
 *                          - relative_top_center:    Uses top-horizontal center bounding box coordinates as anchor point
 *                          - relative_top_right:     Uses top-right bounding box coordinates as anchor point
 *                          - relative_center_left:   Uses vertical center-left bounding box coordinates as anchor point
 *                          - relative_center_right:  Uses vertical center-right bounding box coordinates as anchor point
 *                          - relative_bottom_left:   Uses bottom-left bounding box coordinates as anchor point
 *                          - relative_bottom_center: Uses bottom-horizontal center bounding box coordinates as anchor point
 *                          - relative_bottom_right:  Uses bottom-right bounding box coordinates as anchor point
 *                          - relative_center:        Uses the (horizontal and vertical) center of the bounding box coordinates as anchor point
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_scale_container
INT_VAR
  container_index = "-1"
  scale_x = 1
  scale_y = 1
  numerator = 1
  denominator = 1
  x = 0
  y = 0
  polygon_only = 1
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
  anchor = ~origin~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  ACTION_IF (success && denominator == 0) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Denominator of the scaling factor cannot be 0.~
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_SSHORT 0x38 min_x
      READ_SSHORT 0x3a min_y
      READ_SSHORT 0x3c max_x
      READ_SSHORT 0x3e max_y
    END

    LAF a7#__get_scale_anchor
      INT_VAR min_x min_y max_x max_y x y silent
      STR_VAR anchor
      RET success x y
    END
  END

  ACTION_IF (success && numerator != denominator) BEGIN
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      // patching bounding box
      PATCH_IF (scale_x) BEGIN
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x38 anchor = x numerator denominator RET value END
        WRITE_SHORT 0x38 value
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x3c anchor = x numerator denominator RET value END
        WRITE_SHORT 0x3c value
      END
      PATCH_IF (scale_y) BEGIN
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x3a anchor = y numerator denominator RET value END
        WRITE_SHORT 0x3a value
        LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x3e anchor = y numerator denominator RET value END
        WRITE_SHORT 0x3e value
      END

      // patching locations
      PATCH_IF (NOT polygon_only) BEGIN
        PATCH_IF (scale_x) BEGIN
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x20 anchor = x numerator denominator RET value END
          WRITE_SHORT 0x20 value
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x34 anchor = x numerator denominator RET value END
          WRITE_SHORT 0x34 value
        END

        PATCH_IF (scale_y) BEGIN
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x22 anchor = y numerator denominator RET value END
          WRITE_SHORT 0x22 value
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT 0x36 anchor = y numerator denominator RET value END
          WRITE_SHORT 0x36 value
        END
      END
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~) ~%buffer%~

    // patching vertices
    OUTER_SET num_vertices = $~%are%~(~container~ ~%container_index%~ ~vertex~)
    OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
      OUTER_SET value = $~%are%~(~container~ ~%container_index%~ ~vertex~ ~%idx%~)
      OUTER_SET vx = (value BLSL 16) BASR 16
      OUTER_SET vy = value BASR 16
      ACTION_IF (scale_x) BEGIN
        LAF a7#__scale_coordinate INT_VAR value = vx anchor = x numerator denominator RET vx = value END
      END
      ACTION_IF (scale_y) BEGIN
        LAF a7#__scale_coordinate INT_VAR value = vy anchor = y numerator denominator RET vy = value END
      END
      OUTER_SET $~%are%~(~container~ ~%container_index%~ ~vertex~ ~%idx%~) = (vx & 0xffff) | (vy << 16)
    END
  END
END

/**
 * Action and patch function that adds a new item to a container in the ARE handle.
 *
 * INT_VAR container_index  Index of the container where the item should be added. Omit if you specify the container by name.
 * INT_VAR item_index       Index of the item to insert. Positive values specify absolute item index. Negative values count downwards
 *                          from the end of the item list where -1 points to the index after the last item. (Default: -1)
 * INT_VAR charge1          Number of charges for the first ability or quantity for stackable items. (Default: 0)
 * INT_VAR charge2          Number of charges for the second ability. (Default: 0)
 * INT_VAR charge3          Number of charges for the third ability. (Default: 0)
 * INT_VAR flags            Item flags. (Default: 0)
 * INT_VAR expiry           Item expiration time. Not needed for item definitions outside of saved games. (Default: 0)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR item_resref      Resref of the item. (Default: empty string)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET index                Returns the index of the added item structure if successful, -1 otherwise
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_container_item
INT_VAR
  container_index = "-1"
  item_index = "-1"
  charge1 = 0
  charge2 = 0
  charge3 = 0
  flags = 0
  expiry = 0
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
  item_resref = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET index = "-1"

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  // validating resref
  ACTION_IF (success && STRING_LENGTH ~%item_resref%~ > 8) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: String of parameter "%item_resref%" exceeds 8 characters.~
    END
  END

  // normalizing item index
  ACTION_IF (success) BEGIN
    OUTER_SET num_items = $~%are%~(~container~ ~%container_index%~ ~item~)
    ACTION_IF (item_index < 0) BEGIN
      OUTER_SET item_index = num_items - (ABS item_index) + 1
    END
    OUTER_SET item_index = (item_index > num_items) ? num_items : (item_index < 0) ? 0 : item_index
  END

  ACTION_IF (success) BEGIN
    // expanding item list
    OUTER_FOR (idx = num_items; idx > item_index; --idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%idx%~) $~%are%~(~container~ ~%container_index%~ ~item~ ~%prev_idx%~)
      OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%idx%~ ~resref~) $~%are%~(~container~ ~%container_index%~ ~item~ ~%prev_idx%~ ~resref~)
    END

    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%item_index%~ ~resref~) ~%item_resref%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 20
      WRITE_ASCIIE 0x00 ~%item_resref%~ (8)
      WRITE_SHORT 0x08 expiry
      WRITE_SHORT 0x0a charge1
      WRITE_SHORT 0x0c charge2
      WRITE_SHORT 0x0e charge3
      WRITE_LONG 0x10 flags
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%item_index%~) ~%buffer%~
    OUTER_SET $~%are%~(~container~ ~%container_index%~ ~item~) += 1

    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_LONG 0x44 (THIS + 1)
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~) ~%buffer%~

    OUTER_SET index = item_index
  END
END

/**
 * Action and patch function that alters attributes of an existing container item structure on the ARE handle.
 *
 * INT_VAR container_index  Index of the container where the item should be patched. Omit if you specify the container by name.
 * INT_VAR item_index       Index of the item to patch.
 * INT_VAR charge1          New number of charges for the first ability or quantity for stackable items. (Default: no change)
 * INT_VAR charge2          New number of charges for the second ability. (Default: no change)
 * INT_VAR charge3          New number of charges for the third ability. (Default: no change)
 * INT_VAR flags            New item flags. (Default: no change)
 * INT_VAR expiry           New item expiration time. Not needed for item definitions outside of saved games. (Default: no change)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR item_resref      New resref of the item. (Default: no change)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_container_item
INT_VAR
  container_index = "-1"
  item_index = "-1"
  charge1 = A7_ARE_NO_CHANGE
  charge2 = A7_ARE_NO_CHANGE
  charge3 = A7_ARE_NO_CHANGE
  flags = A7_ARE_NO_CHANGE
  expiry = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
  item_resref = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_items = $~%are%~(~container~ ~%container_index%~ ~item~)
    ACTION_IF (item_index < 0 || item_index >= num_items) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Item index is out of bounds: %item_index%~
      END
    END
  END

  ACTION_IF (success && STRING_LENGTH ~%item_resref%~ > 8) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: String of parameter "item_resref" exceeds 8 characters.~
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~ ~item~ ~%item_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%item_resref%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%item_index%~ ~resref~) ~%item_resref%~
        WRITE_ASCIIE 0x00 ~%item_resref%~ (8)
      END
      PATCH_IF (expiry != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x08 expiry END
      PATCH_IF (charge1 != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x0a charge1 END
      PATCH_IF (charge2 != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x0c charge2 END
      PATCH_IF (charge3 != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x0e charge3 END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x10 flags END
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%item_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing container item structure from the ARE handle.
 *
 * INT_VAR container_index  Index of the container structure. Omit if you specify the container structure by name.
 * INT_VAR item_index       Index of the container item to remove. Omit if you specify the item by resref.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR container_name   Name of the container structure. Omit if you specify the container structure by index.
 * STR_VAR item_resref      Resref of the item to remove. Omit if you specify the item by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_container_item
INT_VAR
  container_index = "-1"
  item_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  container_name = ~~
  item_resref = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = container_index silent STR_VAR are type = ~container~ struct_name = EVAL ~%container_name%~ RET success container_index = index END
  END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index
      INT_VAR index = container_index silent
      STR_VAR are = EVAL ~%are%_container_%container_index%~ type = ~item~ struct_name = EVAL ~%item_resref%~ field_name = ~resref~
      RET success item_index = index
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_items = $~%are%~(~container~ ~%container_index%~ ~item~)
    OUTER_FOR (idx = item_index + 1; idx < num_items; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%prev_idx%~) $~%are%~(~container~ ~%container_index%~ ~item~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~container~ ~%container_index%~ ~item~ ~%prev_idx%~ ~resref~) $~%are%~(~container~ ~%container_index%~ ~item~ ~%idx%~ ~resref~)
    END
    OUTER_SET $~%are%~(~container~ ~%container_index%~ ~item~) -= 1

    OUTER_SPRINT buffer $~%are%~(~container~ ~%container_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_LONG 0x44 (THIS - 1)
    END
    OUTER_SPRINT $~%are%~(~container~ ~%container_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new ambient sound to the ARE handle.
 *
 * INT_VAR loc_x              X coordinate of the ambient sound. (Default: 0)
 * INT_VAR loc_y              Y coordinate of the ambient sound. (Default: 0)
 * INT_VAR radius             Sound radius. (Default: 500)
 * INT_VAR loc_z              Z coordinate (height) of the ambient sound. (Default: 0)
 * INT_VAR pitch_variance     Pitch variance. (Default: 0)
 * INT_VAR volume_variance    Volume variance. (Default: 0)
 * INT_VAR volume             Volumne percentage. (Default: 80)
 * INT_VAR sound_num          Number of active sounds. (Default: 0)
 * INT_VAR delay              Base interval in seconds between sounds from this ambient list. (Default: 0)
 * INT_VAR variation          Base deviation from the base interval. (Default: 0)
 * INT_VAR schedule           Hourly appearance schedule. Each bit refers to a specific hour of the day. (Default: always active)
 * INT_VAR flags              Ambient flags. (Default: 0)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name               Name of the ambient sound. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR wav_resref0, ...   Resref of each sound. Range: wav_resref0 ... wav_resref9. (Default: empty string)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET index                  Returns the index of the added ambient sound structure if successful, -1 otherwise
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_ambient
INT_VAR
  loc_x = 0
  loc_y = 0
  radius = 500
  loc_z = 0
  pitch_variance = 0
  volume_variance = 0
  volume = 80
  sound_num = 0
  delay = 0
  variation = 0
  schedule = 0x00ffffff
  flags = 0
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  wav_resref0 = ~~
  wav_resref1 = ~~
  wav_resref2 = ~~
  wav_resref3 = ~~
  wav_resref4 = ~~
  wav_resref5 = ~~
  wav_resref6 = ~~
  wav_resref7 = ~~
  wav_resref8 = ~~
  wav_resref9 = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_ambients = $~%are%~(~ambient~)

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    OUTER_FOR (i = 0; i < 10; ++i) BEGIN
      OUTER_SPRINT param ~wav_resref%i%~
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~ambient~ ~%num_ambients%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 196

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 loc_x
      WRITE_SHORT 0x22 loc_y
      WRITE_SHORT 0x24 radius
      WRITE_SHORT 0x26 loc_z
      WRITE_LONG 0x28 pitch_variance
      WRITE_SHORT 0x2c volume_variance
      WRITE_SHORT 0x2e volume
      FOR (i = 0; i < 10; ++i) BEGIN
        SPRINT resref EVAL ~%wav_resref%i%%~
        WRITE_ASCIIE (0x30 + i * 8) ~%resref%~ (8)
      END
      WRITE_SHORT 0x80 sound_num
      WRITE_LONG 0x84 delay
      WRITE_LONG 0x88 variation
      WRITE_LONG 0x8c schedule
      WRITE_LONG 0x90 flags
    END
    OUTER_SPRINT $~%are%~(~ambient~ ~%num_ambients%~) ~%buffer%~

    OUTER_SET $~%are%~(~ambient~) += 1
    OUTER_SET index = num_ambients
  END
END

/**
 * Action and patch function that alters attributes of an existing ambient sound structure on the ARE handle.
 *
 * INT_VAR ambient_index      Index of the ambient sound structure to patch. Omit if you specify the ambient sound structure by name.
 * INT_VAR loc_x              New X coordinate of the ambient sound. (Default: no change)
 * INT_VAR loc_y              New Y coordinate of the ambient sound. (Default: no change)
 * INT_VAR radius             New sound radius. (Default: no change)
 * INT_VAR loc_z              New Z coordinate (height) of the ambient sound. (Default: no change)
 * INT_VAR pitch_variance     New pitch variance. (Default: no change)
 * INT_VAR volume_variance    New volume variance. (Default: no change)
 * INT_VAR volume             New volumne percentage. (Default: no change)
 * INT_VAR sound_num          New number of active sounds. (Default: no change)
 * INT_VAR delay              New base interval in seconds between sounds from this ambient list. (Default: no change)
 * INT_VAR variation          New base deviation from the base interval. (Default: no change)
 * INT_VAR schedule           New hourly appearance schedule. Each bit refers to a specific hour of the day. (Default: no change)
 * INT_VAR flags              New ambient flags. (Default: no change)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR ambient_name       Name of the ambient sound structure to patch. Omit if you specify the ambient sound structure by index.
 * STR_VAR name               New name of the ambient sound. May not be longer than 32 characters. (Default: no change)
 * STR_VAR wav_resref0, ...   New resref of each sound. Range: wav_resref0 ... wav_resref9. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_ambient
INT_VAR
  ambient_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  radius = A7_ARE_NO_CHANGE
  loc_z = A7_ARE_NO_CHANGE
  pitch_variance = A7_ARE_NO_CHANGE
  volume_variance = A7_ARE_NO_CHANGE
  volume = A7_ARE_NO_CHANGE
  sound_num = A7_ARE_NO_CHANGE
  delay = A7_ARE_NO_CHANGE
  variation = A7_ARE_NO_CHANGE
  schedule = A7_ARE_NO_CHANGE
  flags = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  ambient_name = ~~
  name = ~?~
  wav_resref0 = ~?~
  wav_resref1 = ~?~
  wav_resref2 = ~?~
  wav_resref3 = ~?~
  wav_resref4 = ~?~
  wav_resref5 = ~?~
  wav_resref6 = ~?~
  wav_resref7 = ~?~
  wav_resref8 = ~?~
  wav_resref9 = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = ambient_index silent STR_VAR are type = ~ambient~ struct_name = EVAL ~%ambient_name%~ RET success ambient_index = index END
  END

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_FOR (i = 0; i < 10; ++i) BEGIN
      OUTER_SPRINT param ~wav_resref%i%~
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~ambient~ ~%ambient_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~ambient~ ~%ambient_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x22 loc_y END
      PATCH_IF (radius != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x24 radius END
      PATCH_IF (loc_z != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x26 loc_z END
      PATCH_IF (pitch_variance != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x28 pitch_variance END
      PATCH_IF (volume_variance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x2c volume_variance END
      PATCH_IF (volume != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x2e volume END
      FOR (i = 0; i < 10; ++i) BEGIN
        SPRINT resref EVAL ~%wav_resref%i%%~
        PATCH_IF (NOT ~%resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE (0x30 + i * 8) ~%resref%~ (8) END
      END
      PATCH_IF (sound_num != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x80 sound_num END
      PATCH_IF (delay != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x84 delay END
      PATCH_IF (variation != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x88 variation END
      PATCH_IF (schedule != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x8c schedule END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x90 flags END
    END
    OUTER_SPRINT $~%are%~(~ambient~ ~%ambient_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing ambient sound structure from the ARE handle.
 *
 * INT_VAR ambient_index  Index of the ambient sound structure to remove. Omit if you specify the ambient sound structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR ambient_name   Name of the ambient sound structure to remove. Omit if you specify the ambient sound structure by index.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_ambient
INT_VAR
  ambient_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  ambient_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = ambient_index silent STR_VAR are type = ~ambient~ struct_name = EVAL ~%ambient_name%~ RET success ambient_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_ambients = $~%are%~(~ambient~)
    OUTER_FOR (idx = ambient_index + 1; idx < num_ambients; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~ambient~ ~%prev_idx%~) $~%are%~(~ambient~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~ambient~ ~%prev_idx%~ ~name~) $~%are%~(~ambient~ ~%idx%~ ~name~)
    END
    OUTER_SET $~%are%~(~ambient~) = num_ambients - 1
  END
END

/**
 * Action and patch function that moves the position of a ambient sound on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR ambient_index  Index of the ambient sound structure to move. Omit if you specify the ambient sound structure by name.
 * INT_VAR x              Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y              Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR z              Amount to move along the z-axis (height).
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR ambient_name   Name of the ambient sound structure to move. Omit if you specify the ambient sound structure by index.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_ambient
INT_VAR
  ambient_index = "-1"
  x = 0
  y = 0
  z = 0
  silent = 0
STR_VAR
  are = ~are~
  ambient_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = ambient_index silent STR_VAR are type = ~ambient~ struct_name = EVAL ~%ambient_name%~ RET success ambient_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~ambient~ ~%ambient_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x20 (THIS + x)
      WRITE_SHORT 0x22 (THIS + y)
      WRITE_SHORT 0x26 (THIS + z)
    END
    OUTER_SPRINT $~%are%~(~ambient~ ~%ambient_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new variable to the ARE handle.
 *
 * INT_VAR value          Value associated with the variable. (Default: 0)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the variable. May not be longer than 32 characters. (Default: empty string)
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET index              Returns the index of the added variable structure if successful, -1 otherwise
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_variable
INT_VAR
  value = 0
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET index = "-1"
  OUTER_SET num_variables = $~%are%~(~variable~)

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~variable~ ~%num_variables%~ ~name~) ~%name%~
    OUTER_SET $~%are%~(~variable~ ~%num_variables%~ ~value~) = value
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 84

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 1
      WRITE_LONG 0x28 value
    END
    OUTER_SPRINT $~%are%~(~variable~ ~%num_variables%~) ~%buffer%~
    OUTER_SET $~%are%~(~variable~) += 1
    OUTER_SET index = num_variables
  END
END

/**
 * Action and patch function that alters attributes of an existing variable structure on the ARE handle.
 *
 * INT_VAR variable_index     Index of the variable structure to patch. Omit if you specify the variable structure by name.
 * INT_VAR value              New value associated with the variable. (Default: no change)
 *                            Note: Because of technical reasons the numeric value 2147385342 cannot be assigned to "value
 *                                  unless the parameter "force_assign" is set to 1.
 * INT_VAR force_assign       Specify 1 to force the content of "value" to be assigned to the specified variable structure.
 *                            See note of the "value" parameter. (Default: 0)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR variable_name      Name of the variable structure to patch. Omit if you specify the variable structure by index.
 * STR_VAR name               New name of the variable. May not be longer than 32 characters. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_variable
INT_VAR
  variable_index = "-1"
  value = A7_ARE_NO_CHANGE
  force_assign = 0
  silent = 0
STR_VAR
  are = ~are~
  variable_name = ~~
  name = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = variable_index silent STR_VAR are type = ~variable~ struct_name = EVAL ~%variable_name%~ RET success variable_index = index END
  END

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~variable~ ~%variable_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~variable~ ~%variable_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (force_assign || value != A7_ARE_NO_CHANGE) BEGIN
        SET $~%are%~(~variable~ ~%variable_index%~ ~value~) = value
        WRITE_SHORT 0x28 value
      END
    END
    OUTER_SPRINT $~%are%~(~variable~ ~%variable_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing variable structure from the ARE handle.
 *
 * INT_VAR variable_index   Index of the variable structure to remove. Omit if you specify the variable structure by name.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR variable_name    Name of the variable structure to remove. Omit if you specify the variable structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_variable
INT_VAR
  variable_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  variable_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = variable_index silent STR_VAR are type = ~variable~ struct_name = EVAL ~%variable_name%~ RET success variable_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_variables = $~%are%~(~variable~)
    OUTER_FOR (idx = variable_index + 1; idx < num_variables; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~variable~ ~%prev_idx%~) $~%are%~(~variable~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~variable~ ~%prev_idx%~ ~name~) $~%are%~(~variable~ ~%idx%~ ~name~)
      OUTER_SET $~%are%~(~variable~ ~%prev_idx%~ ~value~) = $~%are%~(~variable~ ~%idx%~ ~value~)
    END
    OUTER_SET $~%are%~(~variable~) = num_variables - 1
  END
END

/**
 * Action and patch function that sets the explored bitmap in the ARE handle to specified string data.
 *
 * INT_VAR silent     Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are        Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                    Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR bitmask    Bitmap data as string. String may be expanded by unexplored bits or cut off if string size
 *                    doesn't match the area's explored bitmap size. (Default: empty string)
 * RET success        Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%    Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                    (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_set_explored
INT_VAR
  silent = 0
STR_VAR
  are = ~are~
  bitmask = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  // calculating explored bitmap size
  ACTION_IF (success) BEGIN
    OUTER_SET bitmap_size = 0
    LAF a7#__calculate_explored_size STR_VAR are RET bitmap_size = size END
    ACTION_IF (bitmap_size == 0) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Could not determine explored bitmap size.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~explored~)
    OUTER_SET buffer_len = STRING_LENGTH ~%buffer%~
    OUTER_SET bitmask_len = STRING_LENGTH ~%bitmask%~
    ACTION_IF (buffer_len > 0 || bitmask_len > 0) BEGIN
      OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        PATCH_IF (buffer_len < bitmap_size) BEGIN
          // ensure bitmap size is correct
          SET insert_size = bitmap_size - buffer_len
          PATCH_IF (insert_size > 0) BEGIN
            SET insert_pos = buffer_len
            INSERT_BYTES insert_pos insert_size
          END ELSE PATCH_IF (insert_size < 0) BEGIN
            SET delete_size = ABS insert_size
            SET delete_pos = buffer_len - delete_size
            DELETE_BYTES delete_pos delete_size
          END

          // assigning bitmask data
          SET len = (bitmask_len > bitmap_size) ? bitmap_size : bitmask_len
          PATCH_IF (len > 0) BEGIN
            WRITE_ASCIIE 0 ~%bitmask%~ (len)
          END
          // clearing remaining bits
          SET pos = len
          WHILE (pos < bitmap_size) BEGIN
            PATCH_IF ((bitmap_size - pos) > 4) BEGIN
              WRITE_LONG pos 0
              SET pos += 4
            END ELSE PATCH_IF ((bitmap_size - pos) > 2) BEGIN
              WRITE_SHORT pos 0
              SET pos += 2
            END ELSE BEGIN
              WRITE_BYTE pos 0
              SET pos += 1
            END
          END
        END
      END
      OUTER_SPRINT $~%are%~(~explored~) ~%buffer%~
    END
  END
END

/**
 * Action and patch function that clears the whole explored bitmap buffer from the ARE handle.
 *
 * INT_VAR silent     Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are        Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                    Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success        Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%    Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                    (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_clear_explored
INT_VAR
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~explored~) ~~
  END
END

/**
 * Action and patch function that alters the explored bitmap to the "explored" or "unexplored" state in the ARE handle.
 *
 * INT_VAR clear      Specify 1 to explore the whole map. Specify 0 to set the whole map to the unexplored state. (Default: 1)
 * INT_VAR silent     Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are        Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                    Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success        Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%    Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                    (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_explored
INT_VAR
  clear = 1
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  // calculating explored bitmap size
  ACTION_IF (success) BEGIN
    OUTER_SET bitmap_size = 0
    LAF a7#__calculate_explored_size STR_VAR are RET bitmap_size = size END
    ACTION_IF (bitmap_size == 0) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Could not determine explored bitmap size.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~explored~)
    OUTER_SET buffer_len = STRING_LENGTH ~%buffer%~
    ACTION_IF (buffer_len > 0 || clear) BEGIN
      OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        PATCH_IF (buffer_len < bitmap_size) BEGIN
          // ensure bitmap size is correct
          SET insert_size = bitmap_size - buffer_len
          PATCH_IF (insert_size > 0) BEGIN
            SET insert_pos = buffer_len
            INSERT_BYTES insert_pos insert_size
          END ELSE PATCH_IF (insert_size < 0) BEGIN
            SET delete_size = ABS insert_size
            SET delete_pos = buffer_len - delete_size
            DELETE_BYTES delete_pos delete_size
          END

          // setting bits to the specified "explored" state
          SET value = clear ? "-1" : 0
          SET pos = 0
          WHILE (pos < bitmap_size) BEGIN
            PATCH_IF ((bitmap_size - pos) > 4) BEGIN
              WRITE_LONG pos value
              SET pos += 4
            END ELSE PATCH_IF ((bitmap_size - pos) > 2) BEGIN
              WRITE_SHORT pos value
              SET pos += 2
            END ELSE BEGIN
              WRITE_BYTE pos value
              SET pos += 1
            END
          END
        END
      END
      OUTER_SPRINT $~%are%~(~explored~) ~%buffer%~
    END
  END
END

/**
 * Action and patch function that adds a new door to the ARE handle.
 *
 * INT_VAR flags                  Door flags. (Default: 0)
 * INT_VAR cursor_idx             Cursor index (CURSORS.BAM). (Default: 30)
 * INT_VAR trap_detect            Trap detection difficulty. (Default: 0)
 * INT_VAR trap_remove            Trap removal difficulty. (Default: 0)
 * INT_VAR trap_active            Whether the door is trapped. (Default: 0)
 * INT_VAR trap_status            Whether the door trap is detected. (Default: 0)
 * INT_VAR trap_loc_x             Trap launch X coordinate. (Default: 0)
 * INT_VAR trap_loc_y             Trap launch Y coordinate. (Default: 0)
 * INT_VAR detect_diff            Detection difficulty for secret doors. (Default: 0)
 * INT_VAR lock_diff              Lock difficulty. (Default: 0)
 * INT_VAR open_loc_x             X coordinate for toggling the door's open state. (Default: 0)
 * INT_VAR open_loc_y             Y coordinate for toggling the door's open state. (Default: 0)
 * INT_VAR closed_loc_x           X coordinate for toggling the door's closed state. (Default: 0)
 * INT_VAR closed_loc_y           Y coordinate for toggling the door's closed state. (Default: 0)
 * INT_VAR lockpick_strref        Lockpick strref. (Default: -1)
 * INT_VAR dlg_strref             Dialog speaker name strref. (Default: -1)
 * INT_VAR num_vertices_open      Number of open door polygon vertices to add. (Default: 0)
 * INT_VAR num_vertices_closed    Number of closed door polygon vertices to add. (Default: 0)
 * INT_VAR num_cells_open         Number of open door impeded cells to add. (Default: 0)
 * INT_VAR num_cells_closed       Number of closed door impeded cells to add. (Default: 0)
 * INT_VAR vertex_open_0, ...     Array "vertex_open" with "num_vertices_open" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $vertex_open("0"), ...
 * INT_VAR vertex_closed_0, ...   Array "vertex_closed" with "num_vertices_closed" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $vertex_closed("0"), ...
 * INT_VAR cell_open_0, ...       Array "cell_open" with "num_cells_open" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $cell_open("0"), ...
 * INT_VAR cell_closed_0, ...     Array "cell_closed" with "num_cells_closed" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $cell_closed("0"), ...
 * INT_VAR silent                 Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                    Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                                Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name                   Name of the door. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR wed_id                 Door ID linked to the door structure in the associated WED resource. May not be longer than 8 characters. (Default: empty string)
 * STR_VAR open_wav               Open sound of the door. (Default: empty string)
 * STR_VAR close_wav              Close sound of the door. (Default: empty string)
 * STR_VAR key_resref             Resref of the key item to unlock the door. (Default: empty string)
 * STR_VAR door_script            Resref of the door script. (Default: empty string)
 * STR_VAR travel_trigger         Name of the travel region associated with the door. May not be longer than 24 characters. (Default: empty string)
 * STR_VAR dlg_resref             Resref of the door's dialog. (Default: empty string)
 * RET success                    Returns 1 if the operation was successful, 0 otherwise.
 * RET index                      Returns the index of the added door structure if successful, -1 otherwise
 * RET_ARRAY %are%                Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                                (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_door
INT_VAR
  flags = 0
  cursor_idx = 30
  trap_detect = 0
  trap_remove = 0
  trap_active = 0
  trap_status = 0
  trap_loc_x = 0
  trap_loc_y = 0
  detect_diff = 0
  lock_diff = 0
  open_loc_x = 0
  open_loc_y = 0
  closed_loc_x = 0
  closed_loc_y = 0
  lockpick_strref = "-1"
  dlg_strref = "-1"
  num_vertices_open = 0
  num_vertices_closed = 0
  num_cells_open = 0
  num_cells_closed = 0
  // vertex_open_0 = x | (y << 16) ...
  // vertex_closed_0 = x | (y << 16) ...
  // cell_open_0 = x | (y << 16) ...
  // cell_closed_0 = x | (y << 16) ...
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  wed_id = ~~
  open_wav = ~~
  close_wav = ~~
  key_resref = ~~
  door_script = ~~
  travel_trigger = ~~
  dlg_resref = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET index = "-1"
  OUTER_SET num_doors = $~%are%~(~door~)

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating travel trigger name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%travel_trigger%~ > 24) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "travel_trigger" exceeds 24 characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~open_wav~ ~close_wav~ ~key_resref~ ~door_script~ ~dlg_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating vertex arrays
  ACTION_DEFINE_ASSOCIATIVE_ARRAY vertices_info BEGIN
    ~num_vertices_open~ => ~vertex_open~
    ~num_vertices_closed~ => ~vertex_closed~
    ~num_cells_open~ => ~cell_open~
    ~num_cells_closed~ => ~cell_closed~
  END
  ACTION_IF (success) BEGIN
    ACTION_PHP_EACH vertices_info AS count_var => name BEGIN
      OUTER_SET count = EVAL ~%count_var%~
      LAF a7#__are_validate_array INT_VAR count STR_VAR name RET result END
      ACTION_IF (result < count) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: Not enough "%name%" entries defined (expected: %count%, found: %result%)~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~door~ ~%num_doors%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 200

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_ASCIIE 0x20 ~%wed_id%~ (8)
      WRITE_LONG 0x28 flags
      WRITE_SHORT 0x30 num_vertices_open
      WRITE_SHORT 0x32 num_vertices_closed
      LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices_open STR_VAR array = ~vertex_open~ RET min_x max_x min_y max_y END
      WRITE_SHORT 0x38 min_x
      WRITE_SHORT 0x3a min_y
      WRITE_SHORT 0x3c max_x
      WRITE_SHORT 0x3e max_y
      LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices_closed STR_VAR array = ~vertex_closed~ RET min_x max_x min_y max_y END
      WRITE_SHORT 0x40 min_x
      WRITE_SHORT 0x42 min_y
      WRITE_SHORT 0x44 max_x
      WRITE_SHORT 0x46 max_y
      WRITE_SHORT 0x4c num_cells_open
      WRITE_SHORT 0x4e num_cells_closed
      WRITE_ASCIIE 0x58 ~%open_wav%~ (8)
      WRITE_ASCIIE 0x60 ~%close_wav%~ (8)
      WRITE_LONG 0x68 cursor_idx
      WRITE_SHORT 0x6c trap_detect
      WRITE_SHORT 0x6e trap_remove
      WRITE_SHORT 0x70 (trap_active != 0)
      WRITE_SHORT 0x72 (trap_status != 0)
      WRITE_SHORT 0x74 trap_loc_x
      WRITE_SHORT 0x76 trap_loc_y
      WRITE_ASCIIE 0x78 ~%key_resref%~ (8)
      WRITE_ASCIIE 0x80 ~%door_script%~ (8)
      WRITE_LONG 0x88 detect_diff
      WRITE_LONG 0x8c lock_diff
      WRITE_SHORT 0x90 open_loc_x
      WRITE_SHORT 0x92 open_loc_y
      WRITE_SHORT 0x94 closed_loc_x
      WRITE_SHORT 0x96 closed_loc_y
      WRITE_LONG 0x98 lockpick_strref
      WRITE_ASCIIE 0x9c ~%travel_trigger%~ (24)
      WRITE_LONG 0xb4 dlg_strref
      WRITE_ASCIIE 0xb8 ~%dlg_resref%~ (8)
    END
    OUTER_SPRINT $~%are%~(~door~ ~%num_doors%~) ~%buffer%~

    // setting up vertices and cells
    ACTION_PHP_EACH vertices_info AS count_var => array BEGIN
      OUTER_SET count = EVAL ~%count_var%~
      OUTER_SET prev_value = 0
      OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
        OUTER_SET value = IS_AN_INT $~%array%~(~%idx%~) ? $~%array%~(~%idx%~) : prev_value
        OUTER_SET $~%are%~(~door~ ~%num_doors%~ ~%array%~ ~%idx%~) = value
        OUTER_SET prev_value = value
      END
      OUTER_SET $~%are%~(~door~ ~%num_doors%~ ~%array%~) = count
    END

    OUTER_SET $~%are%~(~door~) += 1
    OUTER_SET index = num_doors
  END
END

/**
 * Action and patch function that alters attributes of an existing door structure on the ARE handle.
 *
 * INT_VAR door_index             Index of the door structure to patch. Omit if you specify the door structure by name.
 * INT_VAR flags                  New door flags. (Default: no change)
 * INT_VAR cursor_idx             New cursor index (CURSORS.BAM). (Default: no change)
 * INT_VAR trap_detect            New trap detection difficulty. (Default: no change)
 * INT_VAR trap_remove            New trap removal difficulty. (Default: no change)
 * INT_VAR trap_active            New value of whether the door is trapped. (Default: no change)
 * INT_VAR trap_status            New value of whether the door trap is detected. (Default: no change)
 * INT_VAR trap_loc_x             New trap launch X coordinate. (Default: no change)
 * INT_VAR trap_loc_y             New trap launch Y coordinate. (Default: no change)
 * INT_VAR detect_diff            New detection difficulty for secret doors. (Default: no change)
 * INT_VAR lock_diff              New lock difficulty. (Default: no change)
 * INT_VAR open_loc_x             New X coordinate for toggling the door's open state. (Default: no change)
 * INT_VAR open_loc_y             New Y coordinate for toggling the door's open state. (Default: no change)
 * INT_VAR closed_loc_x           New X coordinate for toggling the door's closed state. (Default: no change)
 * INT_VAR closed_loc_y           New Y coordinate for toggling the door's closed state. (Default: no change)
 * INT_VAR lockpick_strref        New lockpick strref. (Default: no change)
 * INT_VAR dlg_strref             New dialog speaker name strref. (Default: no change)
 * INT_VAR num_vertices_open      New number of open door polygon vertices. If this parameter is specified then the current door vertices
 *                                are updated with the specified vertex definitions. (Default: no change)
 * INT_VAR num_vertices_closed    New number of closed door polygon vertices. If this parameter is specified then the current door vertices
 *                                are updated with the specified vertex definitions. (Default: no change)
 * INT_VAR num_cells_open         New number of open door impeded cells. If this parameter is specified then the current door cells
 *                                are updated with the specified vertex definitions. (Default: no change)
 * INT_VAR num_cells_closed       New number of closed door impeded cells. If this parameter is specified then the current door cells
 *                                are updated with the specified vertex definitions. (Default: no change)
 * INT_VAR vertex_open_0, ...     Array "vertex_open" with "num_vertices_open" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $vertex_open("0"), ...
 * INT_VAR vertex_closed_0, ...   Array "vertex_closed" with "num_vertices_closed" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $vertex_closed("0"), ...
 * INT_VAR cell_open_0, ...       Array "cell_open" with "num_cells_open" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $cell_open("0"), ...
 * INT_VAR cell_closed_0, ...     Array "cell_closed" with "num_cells_closed" vertex coordinates, as "X coordinate | (Y coordinate << 16)".
 *                                Alternate notation: $cell_closed("0"), ...
 * INT_VAR silent                 Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                    Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                                Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR door_name              Name of the door structure to patch. Omit if you specify the door structure by index.
 * STR_VAR name                   New name of the door. May not be longer than 32 characters. (Default: no change)
 * STR_VAR wed_id                 New door ID linked to the door structure in the associated WED resource. May not be longer than 8 characters. (Default: no change)
 * STR_VAR open_wav               New open sound of the door. (Default: no change)
 * STR_VAR close_wav              New close sound of the door. (Default: no change)
 * STR_VAR key_resref             New resref of the key item to unlock the door. (Default: no change)
 * STR_VAR door_script            New resref of the door script. (Default: no change)
 * STR_VAR travel_trigger         New name of the travel region associated with the door. May not be longer than 24 characters. (Default: no change)
 * STR_VAR dlg_resref             New resref of the door's dialog. (Default: no change)
 * RET success                    Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%                Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                                (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_door
INT_VAR
  door_index = "-1"
  flags = A7_ARE_NO_CHANGE
  cursor_idx = A7_ARE_NO_CHANGE
  trap_detect = A7_ARE_NO_CHANGE
  trap_remove = A7_ARE_NO_CHANGE
  trap_active = A7_ARE_NO_CHANGE
  trap_status = A7_ARE_NO_CHANGE
  trap_loc_x = A7_ARE_NO_CHANGE
  trap_loc_y = A7_ARE_NO_CHANGE
  detect_diff = A7_ARE_NO_CHANGE
  lock_diff = A7_ARE_NO_CHANGE
  open_loc_x = A7_ARE_NO_CHANGE
  open_loc_y = A7_ARE_NO_CHANGE
  closed_loc_x = A7_ARE_NO_CHANGE
  closed_loc_y = A7_ARE_NO_CHANGE
  lockpick_strref = A7_ARE_NO_CHANGE
  dlg_strref = A7_ARE_NO_CHANGE
  num_vertices_open = A7_ARE_NO_CHANGE
  num_vertices_closed = A7_ARE_NO_CHANGE
  num_cells_open = A7_ARE_NO_CHANGE
  num_cells_closed = A7_ARE_NO_CHANGE
  // vertex_open_0 = x | (y << 16) ...
  // vertex_closed_0 = x | (y << 16) ...
  // cell_open_0 = x | (y << 16) ...
  // cell_closed_0 = x | (y << 16) ...
  silent = 0
STR_VAR
  are = ~are~
  door_name = ~~
  name = ~?~
  wed_id = ~?~
  open_wav = ~?~
  close_wav = ~?~
  key_resref = ~?~
  door_script = ~?~
  travel_trigger = ~?~
  dlg_resref = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = door_index silent STR_VAR are type = ~door~ struct_name = EVAL ~%door_name%~ RET success door_index = index END
  END

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating travel trigger name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%travel_trigger%~ > 24) BEGIN
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "travel_trigger" exceeds 24 characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~open_wav~ ~close_wav~ ~key_resref~ ~door_script~ ~dlg_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  // validating vertex arrays
  ACTION_DEFINE_ASSOCIATIVE_ARRAY vertices_info BEGIN
    ~num_vertices_open~ => ~vertex_open~
    ~num_vertices_closed~ => ~vertex_closed~
    ~num_cells_open~ => ~cell_open~
    ~num_cells_closed~ => ~cell_closed~
  END
  ACTION_IF (success) BEGIN
    ACTION_PHP_EACH vertices_info AS count_var => array BEGIN
      OUTER_SET count = EVAL ~%count_var%~
      ACTION_IF (count != A7_ARE_NO_CHANGE) BEGIN
        OUTER_SET count_old = $~%are%~(~door~ ~%door_index%~ ~%array%~)
        OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
          OUTER_SET value = VARIABLE_IS_SET $~%array%~(~%idx%~) ? $~%array%~(~%idx%~) : A7_ARE_NO_CHANGE
          ACTION_IF (idx >= count_old && value == A7_ARE_NO_CHANGE) BEGIN
            OUTER_SET success = 0
            ACTION_IF (NOT silent) BEGIN
              WARN ~WARNING: Not enough "%array%" entries defined (expected: %count%, found: %idx%)~
            END
            OUTER_SET idx = count
          END ELSE ACTION_IF (value == A7_ARE_NO_CHANGE) BEGIN
            // resolving placeholder constant
            OUTER_SET $~%array%~(~%idx%~) = $~%are%~(~door~ ~%door_index%~ ~%array%~ ~%idx%~)
          END
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~door~ ~%door_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~door~ ~%door_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (NOT ~%wed_id%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x20 ~%wed_id%~ (8) END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x28 flags END
      PATCH_IF (num_vertices_open != A7_ARE_NO_CHANGE) BEGIN
        WRITE_SHORT 0x30 num_vertices_open
        LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices_open STR_VAR array = ~vertex_open~ RET min_x max_x min_y max_y END
        WRITE_SHORT 0x38 min_x
        WRITE_SHORT 0x3a min_y
        WRITE_SHORT 0x3c max_x
        WRITE_SHORT 0x3e max_y
      END
      PATCH_IF (num_vertices_closed != A7_ARE_NO_CHANGE) BEGIN
        WRITE_SHORT 0x32 num_vertices_closed
        LPF a7#__are_calculate_poly_bounding_box INT_VAR count = num_vertices_closed STR_VAR array = ~vertex_closed~ RET min_x max_x min_y max_y END
        WRITE_SHORT 0x40 min_x
        WRITE_SHORT 0x42 min_y
        WRITE_SHORT 0x44 max_x
        WRITE_SHORT 0x46 max_y
      END
      PATCH_IF (num_cells_open != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x4c num_cells_open END
      PATCH_IF (num_cells_closed != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x4e num_cells_closed END
      PATCH_IF (NOT ~%open_wav%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x58 ~%open_wav%~ (8) END
      PATCH_IF (NOT ~%close_wav%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x60 ~%close_wav%~ (8) END
      PATCH_IF (cursor_idx != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x68 cursor_idx END
      PATCH_IF (trap_detect != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x6c trap_detect END
      PATCH_IF (trap_remove != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x6e trap_remove END
      PATCH_IF (trap_active != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x70 (trap_active != 0) END
      PATCH_IF (trap_status != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x72 (trap_status != 0) END
      PATCH_IF (trap_loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x74 trap_loc_x END
      PATCH_IF (trap_loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x76 trap_loc_y END
      PATCH_IF (NOT ~%key_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x78 ~%key_resref%~ (8) END
      PATCH_IF (NOT ~%door_script%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x80 ~%door_script%~ (8) END
      PATCH_IF (detect_diff != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x88 detect_diff END
      PATCH_IF (lock_diff != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x8c lock_diff END
      PATCH_IF (open_loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x90 open_loc_x END
      PATCH_IF (open_loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x92 open_loc_y END
      PATCH_IF (closed_loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x94 closed_loc_x END
      PATCH_IF (closed_loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x96 closed_loc_y END
      PATCH_IF (lockpick_strref != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x98 lockpick_strref END
      PATCH_IF (NOT ~%travel_trigger%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x9c ~%travel_trigger%~ (24) END
      PATCH_IF (dlg_strref != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0xb4 dlg_strref END
      PATCH_IF (NOT ~%dlg_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0xb8 ~%dlg_resref%~ (8) END
    END
    OUTER_SPRINT $~%are%~(~door~ ~%door_index%~) ~%buffer%~

    // patching vertices and cells
    ACTION_PHP_EACH vertices_info AS count_var => array BEGIN
      OUTER_SET count = EVAL ~%count_var%~
      ACTION_IF (count != A7_ARE_NO_CHANGE) BEGIN
        OUTER_SET prev_value = 0
        OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
          OUTER_SET value = IS_AN_INT $~%array%~(~%idx%~) ? $~%array%~(~%idx%~) : prev_value
          OUTER_SET $~%are%~(~door~ ~%door_index%~ ~%array%~ ~%idx%~) = value
          OUTER_SET prev_value = value
        END
        OUTER_SET $~%are%~(~door~ ~%door_index%~ ~%array%~) = count
      END
    END
  END
END

/**
 * Action and patch function that removes an existing door structure from the ARE handle.
 *
 * INT_VAR door_index     Index of the door structure to remove. Omit if you specify the door structure by name.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR door_name      Name of the door structure to remove. Omit if you specify the door structure by index.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_door
INT_VAR
  door_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  door_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = door_index silent STR_VAR are type = ~door~ struct_name = EVAL ~%door_name%~ RET success door_index = index END
  END

  ACTION_IF (success) BEGIN
    ACTION_DEFINE_ARRAY vertices_info BEGIN ~vertex_open~ ~vertex_closed~ ~cell_open~ ~cell_closed~ END
    OUTER_SET num_doors = $~%are%~(~door~)
    OUTER_FOR (idx = door_index + 1; idx < num_doors; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~door~ ~%prev_idx%~) $~%are%~(~door~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~door~ ~%prev_idx%~ ~name~) $~%are%~(~door~ ~%idx%~ ~name~)

      // vertex and cell lists
      ACTION_PHP_EACH vertices_info AS _ => array BEGIN
        OUTER_SET count = $~%are%~(~door~ ~%idx%~ ~%array%~)
        OUTER_FOR (idx2 = 0; idx2 < count; ++idx2) BEGIN
          OUTER_SET $~%are%~(~door~ ~%prev_idx%~ ~%array%~ ~%idx2%~) = $~%are%~(~door~ ~%idx%~ ~%array%~ ~%idx2%~)
        END
        OUTER_SET $~%are%~(~door~ ~%prev_idx%~ ~%array%~) = count
      END
    END
    OUTER_SET $~%are%~(~door~) = num_doors - 1
  END
END

/**
 * Action and patch function that moves the position of a door on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR door_index     Index of the door structure to move. Omit if you specify the door structure by name.
 * INT_VAR x              Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y              Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR door_name      Name of the door structure to move. Omit if you specify the door structure by index.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_door
INT_VAR
  door_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
  door_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = door_index silent STR_VAR are type = ~door~ struct_name = EVAL ~%door_name%~ RET success door_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~door~ ~%door_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x38 (THIS + x)
      WRITE_SHORT 0x3a (THIS + y)
      WRITE_SHORT 0x3c (THIS + x)
      WRITE_SHORT 0x3e (THIS + y)
      WRITE_SHORT 0x40 (THIS + x)
      WRITE_SHORT 0x42 (THIS + y)
      WRITE_SHORT 0x44 (THIS + x)
      WRITE_SHORT 0x46 (THIS + y)
      WRITE_SHORT 0x74 (THIS + x)
      WRITE_SHORT 0x76 (THIS + y)
      WRITE_SHORT 0x90 (THIS + x)
      WRITE_SHORT 0x92 (THIS + y)
      WRITE_SHORT 0x94 (THIS + x)
      WRITE_SHORT 0x96 (THIS + y)
    END
    OUTER_SPRINT $~%are%~(~door~ ~%door_index%~) ~%buffer%~

    // moving vertices and cells
    ACTION_FOR_EACH array IN ~vertex_open~ ~vertex_closed~ ~cell_open~ ~cell_closed~ BEGIN
      OUTER_SET count = $~%are%~(~door~ ~%door_index%~ ~%array%~)
      OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
        OUTER_SET value = $~%are%~(~door~ ~%door_index%~ ~%array%~ ~%idx%~)
        OUTER_SET vx = (value BLSL 16) BASR 16
        OUTER_SET vx += x
        OUTER_SET vy = value BASR 16
        OUTER_SET vy += y
        OUTER_SET $~%are%~(~door~ ~%door_index%~ ~%array%~ ~%idx%~) = (vx & 0xffff) | (vy << 16)
      END
    END
  END
END

/**
 * Action and patch function that scales a door polygon on the ARE handle by a specified factor in either direction.
 * Impeded cells are not updated by this operation.
 *
 * INT_VAR door_index     Index of the door structure to scale. Omit if you specify the door structure by name.
 * INT_VAR scale_x        Indicates whether to scale horizontally. (Default: 1)
 * INT_VAR scale_y        Indicates whether to scale vertically. (Default: 1)
 * INT_VAR numerator      Numerator (top value of a fraction) of the scaling factor. (Default: 1)
 *                        Note: A negative fractional value will mirror the polygon vertex coordinates around the anchor point.
 * INT_VAR denominator    Denominator (bottom value of a fraction) of the scaling factor. Must not be 0. (Default: 1)
 *                        Note: A negative fractional value will mirror the polygon vertex coordinates around the anchor point.
 * INT_VAR x              If "custom" anchor is specified then this value defines the absolute x coordinate of the anchor point. (Default: 0)
 * INT_VAR y              If "custom" anchor is specified then this value defines the absolute y coordinate of the anchor point. (Default: 0)
 * INT_VAR polygon_only   Specify 1 to scale only the door polygon vertices. Specify 0 to scale location coordinates as well. (Default: 1)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR door_name      Name of the door structure to remove. Omit if you specify the door structure by index.
 * STR_VAR anchor         Anchor point for the scaling operation. Relative movement of the vertices is centered on this position. (Default: "origin")
 *                        Note: For the "relative_*" anchor types a bounding box is calculated that encloses both open and closed door polygons.
 *                              This anchor point is also used for scaling locations if the "polygon_only" parameter is set to 0.
 *                        Supported anchor points:
 *                        - origin:                 Uses absolute coordinates (0,0) as anchor point
 *                        - custom:                 Uses parameters x and y as anchor point coordinates
 *                        - relative_top_left:      Uses top-left bounding box coordinates as anchor point
 *                        - relative_top_center:    Uses top-horizontal center bounding box coordinates as anchor point
 *                        - relative_top_right:     Uses top-right bounding box coordinates as anchor point
 *                        - relative_center_left:   Uses vertical center-left bounding box coordinates as anchor point
 *                        - relative_center_right:  Uses vertical center-right bounding box coordinates as anchor point
 *                        - relative_bottom_left:   Uses bottom-left bounding box coordinates as anchor point
 *                        - relative_bottom_center: Uses bottom-horizontal center bounding box coordinates as anchor point
 *                        - relative_bottom_right:  Uses bottom-right bounding box coordinates as anchor point
 *                        - relative_center:        Uses the (horizontal and vertical) center of the bounding box coordinates as anchor point
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_scale_door
INT_VAR
  door_index = "-1"
  scale_x = 1
  scale_y = 1
  numerator = 1
  denominator = 1
  x = 0
  y = 0
  polygon_only = 1
  silent = 0
STR_VAR
  are = ~are~
  door_name = ~~
  anchor = ~origin~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = door_index silent STR_VAR are type = ~door~ struct_name = EVAL ~%door_name%~ RET success door_index = index END
  END

  ACTION_IF (success && denominator == 0) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Denominator of the scaling factor cannot be 0.~
    END
  END

  ACTION_IF (success) BEGIN
    // calculating anchor points
    OUTER_SPRINT buffer $~%are%~(~door~ ~%door_index%~)
    OUTER_PATCH ~%buffer%~ BEGIN
      READ_SSHORT 0x38 o_min_x
      READ_SSHORT 0x3a o_min_y
      READ_SSHORT 0x3c o_max_x
      READ_SSHORT 0x3e o_max_y
      READ_SSHORT 0x40 c_min_x
      READ_SSHORT 0x42 c_min_y
      READ_SSHORT 0x44 c_max_x
      READ_SSHORT 0x46 c_max_y
    END

    OUTER_SET min_x = (o_min_x < c_min_x) ? o_min_x : c_min_x
    OUTER_SET min_y = (o_min_y < c_min_y) ? o_min_y : c_min_y
    OUTER_SET max_x = (o_max_x > c_max_x) ? o_max_x : c_max_x
    OUTER_SET max_y = (o_max_y > c_max_y) ? o_max_y : c_max_y
    LAF a7#__get_scale_anchor
      INT_VAR min_x min_y max_x max_y x y silent
      STR_VAR anchor
      RET success x y
    END
  END

  ACTION_IF (success && numerator != denominator) BEGIN
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      // patching bounding boxes
      PATCH_FOR_EACH base_ofs IN 0x38 0x40 BEGIN
        PATCH_IF (scale_x) BEGIN
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT (base_ofs + 0x00) anchor = x numerator denominator RET value END
          WRITE_SHORT (base_ofs + 0x00) value
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT (base_ofs + 0x04) anchor = x numerator denominator RET value END
          WRITE_SHORT (base_ofs + 0x04) value
        END
        PATCH_IF (scale_y) BEGIN
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT (base_ofs + 0x02) anchor = y numerator denominator RET value END
          WRITE_SHORT (base_ofs + 0x02) value
          LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT (base_ofs + 0x06) anchor = y numerator denominator RET value END
          WRITE_SHORT (base_ofs + 0x06) value
        END
      END

      // patching locations
      PATCH_IF (NOT polygon_only) BEGIN
        PATCH_FOR_EACH base_ofs IN 0x74 0x90 0x94 BEGIN
          PATCH_IF (scale_x) BEGIN
            LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT (base_ofs + 0x00) anchor = x numerator denominator RET value END
            WRITE_SHORT (base_ofs + 0x00) value
          END
          PATCH_IF (scale_y) BEGIN
            LPF a7#__scale_coordinate INT_VAR value = SSHORT_AT (base_ofs + 0x02) anchor = y numerator denominator RET value END
            WRITE_SHORT (base_ofs + 0x02) value
          END
        END
      END
    END
    OUTER_SPRINT $~%are%~(~door~ ~%door_index%~) ~%buffer%~

    // patching vertices
    ACTION_FOR_EACH array IN ~vertex_open~ ~vertex_closed~ BEGIN
      OUTER_SET num_vertices = $~%are%~(~door~ ~%door_index%~ ~%array%~)
      OUTER_FOR (idx = 0; idx < num_vertices; ++idx) BEGIN
        OUTER_SET value = $~%are%~(~door~ ~%door_index%~ ~%array%~ ~%idx%~)
        OUTER_SET vx = (value BLSL 16) BASR 16
        OUTER_SET vy = value BASR 16
        ACTION_IF (scale_x) BEGIN
          LAF a7#__scale_coordinate INT_VAR value = vx anchor = x numerator denominator RET vx = value END
        END
        ACTION_IF (scale_y) BEGIN
          LAF a7#__scale_coordinate INT_VAR value = vy anchor = y numerator denominator RET vy = value END
        END
        OUTER_SET $~%are%~(~door~ ~%door_index%~ ~%array%~ ~%idx%~) = (vx & 0xffff) | (vy << 16)
      END
    END
  END
END

/**
 * Action and patch function that adds a new animation to the ARE handle.
 *
 * INT_VAR loc_x          X coordinate of the animation. (Default: 0)
 * INT_VAR loc_y          Y coordinate of the animation. (Default: 0)
 * INT_VAR schedule       Hourly appearance schedule. Each bit refers to a specific hour of the day. (Default: always active)
 * INT_VAR bam_seq        The BAM sequence number. (Default: 0)
 * INT_VAR bam_frame      The BAM frame number. (Default: 0)
 * INT_VAR flags          Animation flags. (Default: 0)
 * INT_VAR loc_z          Height of the animation. (Default: 0)
 * INT_VAR transparent    BAM transparency/translucency in range 0 - 255 (the higher the more translucent). (Default: 0)
 * INT_VAR init_frame     Starting frame of the animation playback. (0 indicates random frame unless synchronized flag is set). (Default: 0)
 * INT_VAR loop_chance    Chance of looping (%). (Default: 0)
 * INT_VAR skip_cycles    Start delay in frames. (Default: 0)
 * INT_VAR width          (EE only) Animation width. This is only required for WBM and PVRZ resources. (Default: 0)
 * INT_VAR height         (EE only) Animation height. This is only required for WBM and PVRZ resources. (Default: 0)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name           Name of the animation. May not be longer than 32 characters. (Default: empty string)
 * STR_VAR bam_resref     Resref of the BAM animation. EE games can also specify WBM and PVRZ resources. (Default: empty string)
 * STR_VAR bmp_resref     Resref of the palette bitmap. Palette is only supported by BAM V1 animations. (Default: empty string).
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET index              Returns the index of the added animation structure if successful, -1 otherwise
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_animation
INT_VAR
  loc_x = 0
  loc_y = 0
  schedule = 0x00ffffff
  bam_seq = 0
  bam_frame = 0
  flags = 0
  loc_z = 0
  transparent = 0
  init_frame = 0
  loop_chance = 0
  skip_cycles = 0
  width = 0
  height = 0
  silent = 0
STR_VAR
  are = ~are~
  name = ~~
  bam_resref = ~~
  bmp_resref = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_animations = $~%are%~(~animation~)

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~bam_resref~ ~bmp_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT $~%are%~(~animation~ ~%num_animations%~ ~name~) ~%name%~
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 76

      WRITE_ASCIIE 0x00 ~%name%~ (32)
      WRITE_SHORT 0x20 loc_x
      WRITE_SHORT 0x22 loc_y
      WRITE_LONG 0x24 schedule
      WRITE_ASCIIE 0x28 ~%bam_resref%~ (8)
      WRITE_SHORT 0x30 bam_seq
      WRITE_SHORT 0x32 bam_frame
      WRITE_LONG 0x34 flags
      WRITE_SHORT 0x38 loc_z
      WRITE_SHORT 0x3a transparent
      WRITE_SHORT 0x3c init_frame
      WRITE_BYTE 0x3e loop_chance
      WRITE_BYTE 0x3f skip_cycles
      WRITE_ASCIIE 0x40 ~%bmp_resref%~ (8)
      PATCH_IF (is_v1 && is_ee) BEGIN
        WRITE_SHORT 0x48 width
        WRITE_SHORT 0x4a height
      END
    END
    OUTER_SPRINT $~%are%~(~animation~ ~%num_animations%~) ~%buffer%~
    OUTER_SET $~%are%~(~animation~) += 1
    OUTER_SET index = num_animations
  END
END

/**
 * Action and patch function that alters attributes of an existing animation structure on the ARE handle.
 *
 * INT_VAR animation_index  Index of the animation structure to patch. Omit if you specify the animation structure by name.
 * INT_VAR loc_x            New X coordinate of the animation. (Default: no change)
 * INT_VAR loc_y            New Y coordinate of the animation. (Default: no change)
 * INT_VAR schedule         New hourly appearance schedule. Each bit refers to a specific hour of the day. (Default: no change)
 * INT_VAR bam_seq          New BAM sequence number. (Default: no change)
 * INT_VAR bam_frame        New BAM frame number. (Default: no change)
 * INT_VAR flags            New animation flags. (Default: no change)
 * INT_VAR loc_z            New height of the animation. (Default: no change)
 * INT_VAR transparent      New BAM transparency/translucency in range 0 - 255 (the higher the more translucent). (Default: no change)
 * INT_VAR init_frame       New starting frame of the animation playback. (0 indicates random frame unless synchronized flag is set). (Default: no change)
 * INT_VAR loop_chance      New chance of looping (%). (Default: no change)
 * INT_VAR skip_cycles      New start delay in frames. (Default: no change)
 * INT_VAR width            (EE only) New animation width. This is only required for WBM and PVRZ resources. (Default: no change)
 * INT_VAR height           (EE only) New animation height. This is only required for WBM and PVRZ resources. (Default: no change)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR animation_name   Name of the animation structure to patch. Omit if you specify the animation structure by index.
 * STR_VAR name             New name of the animation. May not be longer than 32 characters. (Default: no change)
 * STR_VAR bam_resref       New resref of the BAM animation. EE games can also specify WBM and PVRZ resources. (Default: no change)
 * STR_VAR bmp_resref       New resref of the palette bitmap. Palette is only supported by BAM V1 animations. (Default: no change).
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_animation
INT_VAR
  animation_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  schedule = A7_ARE_NO_CHANGE
  bam_seq = A7_ARE_NO_CHANGE
  bam_frame = A7_ARE_NO_CHANGE
  flags = A7_ARE_NO_CHANGE
  loc_z = A7_ARE_NO_CHANGE
  transparent = A7_ARE_NO_CHANGE
  init_frame = A7_ARE_NO_CHANGE
  loop_chance = A7_ARE_NO_CHANGE
  skip_cycles = A7_ARE_NO_CHANGE
  width = A7_ARE_NO_CHANGE
  height = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  animation_name = ~~
  name = ~?~
  bam_resref = ~?~
  bmp_resref = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = animation_index silent STR_VAR are type = ~animation~ struct_name = EVAL ~%animation_name%~ RET success animation_index = index END
  END

  // validating name
  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~bam_resref~ ~bmp_resref~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~animation~ ~%animation_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN
        SPRINT $~%are%~(~animation~ ~%animation_index%~ ~name~) ~%name%~
        WRITE_ASCIIE 0x00 ~%name%~ (32)
      END

      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x20 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x22 loc_y END
      PATCH_IF (schedule != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x24 schedule END
      PATCH_IF (NOT ~%bam_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x28 ~%bam_resref%~ (8) END
      PATCH_IF (bam_seq != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x30 bam_seq END
      PATCH_IF (bam_frame != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x32 bam_frame END
      PATCH_IF (flags != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x34 flags END
      PATCH_IF (loc_z != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x38 loc_z END
      PATCH_IF (transparent != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x3a transparent END
      PATCH_IF (init_frame != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x3c init_frame END
      PATCH_IF (loop_chance != A7_ARE_NO_CHANGE) BEGIN WRITE_BYTE 0x3e loop_chance END
      PATCH_IF (skip_cycles != A7_ARE_NO_CHANGE) BEGIN WRITE_BYTE 0x3f skip_cycles END
      PATCH_IF (NOT ~%bmp_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x40 ~%bmp_resref%~ (8) END
      PATCH_IF (is_v1 && is_ee) BEGIN
        PATCH_IF (width != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x48 width END
        PATCH_IF (height != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x4a height END
      END
    END
    OUTER_SPRINT $~%are%~(~animation~ ~%animation_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing animation structure from the ARE handle.
 *
 * INT_VAR animation_index  Index of the animation structure to remove. Omit if you specify the animation structure by name.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR animation_name   Name of the animation structure to remove. Omit if you specify the animation structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_animation
INT_VAR
  animation_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  animation_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = animation_index silent STR_VAR are type = ~animation~ struct_name = EVAL ~%animation_name%~ RET success animation_index = index END
  END

  ACTION_IF (success) BEGIN
    OUTER_SET num_animations = $~%are%~(~animation~)
    OUTER_FOR (idx = animation_index + 1; idx < num_animations; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~animation~ ~%prev_idx%~) $~%are%~(~animation~ ~%idx%~)
      OUTER_SPRINT $~%are%~(~animation~ ~%prev_idx%~ ~name~) $~%are%~(~animation~ ~%idx%~ ~name~)
    END
    OUTER_SET $~%are%~(~animation~) = num_animations - 1
  END
END

/**
 * Action and patch function that moves the position of a animation on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR animation_index  Index of the animation structure to move. Omit if you specify the animation structure by name.
 * INT_VAR x                Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y                Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR animation_name   Name of the animation structure to move. Omit if you specify the animation structure by index.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_animation
INT_VAR
  animation_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
  animation_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    LAF a7#__are_get_struct_index INT_VAR index = animation_index silent STR_VAR are type = ~animation~ struct_name = EVAL ~%animation_name%~ RET success animation_index = index END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~animation~ ~%animation_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x20 (THIS + x)
      WRITE_SHORT 0x22 (THIS + y)
    END
    OUTER_SPRINT $~%are%~(~animation~ ~%animation_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that alters attributes of the songs structure on an ARE handle.
 *
 * INT_VAR song_day           New day song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_night         New night song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_victory       New victory song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_battle        New battle song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_defeat        New defeat song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_day_alt       New alternate day song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_night_alt     New alternate night song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_victory_alt   New alternate victory song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_battle_alt    New alternate battle song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_defeat_alt    New alternate defeat song reference number (SONGLIST.2DA). (Default: no change)
 * INT_VAR song_day_vol       New main day ambient volume (%). (Default: no change)
 * INT_VAR song_night_vol     New main night ambient volume (%). (Default: no change)
 * INT_VAR reverb             New reverb definition from REVERB.2DA or REVERB.IDS if available. (Default: no change)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR song_day0          New resref of the first main day ambient sound. (Default: no change)
 * STR_VAR song_day1          New resref of the second main day ambient sound. (Default: no change)
 * STR_VAR song_night0        New resref of the first main night ambient sound. (Default: no change)
 * STR_VAR song_night1        New resref of the second main night ambient sound. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_songs
INT_VAR
  song_day = A7_ARE_NO_CHANGE
  song_night = A7_ARE_NO_CHANGE
  song_victory = A7_ARE_NO_CHANGE
  song_battle = A7_ARE_NO_CHANGE
  song_defeat = A7_ARE_NO_CHANGE
  song_day_alt = A7_ARE_NO_CHANGE
  song_night_alt = A7_ARE_NO_CHANGE
  song_victory_alt = A7_ARE_NO_CHANGE
  song_battle_alt = A7_ARE_NO_CHANGE
  song_defeat_alt = A7_ARE_NO_CHANGE
  song_day_vol = A7_ARE_NO_CHANGE
  song_night_vol = A7_ARE_NO_CHANGE
  reverb = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  song_day0 = ~?~
  song_day1 = ~?~
  song_night0 = ~?~
  song_night1 = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END

  // validating resrefs
  ACTION_IF (success) BEGIN
    ACTION_FOR_EACH param IN ~song_day0~ ~song_day1~ ~song_night0~ ~song_night1~ BEGIN
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~songs~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (song_day != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x00 song_day END
      PATCH_IF (song_night != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x04 song_night END
      PATCH_IF (song_victory != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x08 song_victory END
      PATCH_IF (song_battle != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x0c song_battle END
      PATCH_IF (song_defeat != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x10 song_defeat END
      PATCH_IF (song_day_alt != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x14 song_day_alt END
      PATCH_IF (song_night_alt != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x18 song_night_alt END
      PATCH_IF (song_victory_alt != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x1c song_victory_alt END
      PATCH_IF (song_battle_alt != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x20 song_battle_alt END
      PATCH_IF (song_defeat_alt != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x24 song_defeat_alt END
      PATCH_IF (NOT ~%song_day0%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x28 ~%song_day0%~ (8) END
      PATCH_IF (NOT ~%song_day1%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x30 ~%song_day1%~ (8) END
      PATCH_IF (song_day_vol != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x38 song_day_vol END
      PATCH_IF (NOT ~%song_night0%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x3c ~%song_night0%~ (8) END
      PATCH_IF (NOT ~%song_night1%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x44 ~%song_night1%~ (8) END
      PATCH_IF (song_night_vol != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x4c song_night_vol END
      PATCH_IF (reverb != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x50 reverb END
    END
    OUTER_SPRINT $~%are%~(~songs~) ~%buffer%~
  END
END

/**
 * Action and patch function that alters attributes of the rest encounters structure on an ARE handle.
 *
 * INT_VAR cre_strref0, ...   New strref of string that is displayed upon party ambush. Range: cre_strref0 ... cre_strref9. (Default: no change)
 * INT_VAR spawn_num          New number of spawned creatures. (Default: no change)
 * INT_VAR difficulty         New encounter difficulty. (Default: no change)
 * INT_VAR duration           New creature's removal timer, in seconds. (Default: no change)
 * INT_VAR wander_distance    New movement restriction distance. (Default: no change)
 * INT_VAR follow_distance    New movement restriction distance (move to object). (Default: no change)
 * INT_VAR max_num            New max. number of spawned creatures. (Default: no change)
 * INT_VAR enable             New value of whether rest encounters are enabled. (Default: no change)
 * INT_VAR day_prob           Probability (day) per hour. (Default: no change)
 * INT_VAR night_prob         Probability (night) per hour. (Default: no change)
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR name               Name of the rest encounters structures (unused by the engine). (Default: no change)
 * STR_VAR cre_resref0, ...   Resref of the creature to spawn. Range: cre_resref0 ... cre_resref9. (Default: no change)
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_rest
INT_VAR
  cre_strref0 = A7_ARE_NO_CHANGE
  cre_strref1 = A7_ARE_NO_CHANGE
  cre_strref2 = A7_ARE_NO_CHANGE
  cre_strref3 = A7_ARE_NO_CHANGE
  cre_strref4 = A7_ARE_NO_CHANGE
  cre_strref5 = A7_ARE_NO_CHANGE
  cre_strref6 = A7_ARE_NO_CHANGE
  cre_strref7 = A7_ARE_NO_CHANGE
  cre_strref8 = A7_ARE_NO_CHANGE
  cre_strref9 = A7_ARE_NO_CHANGE
  spawn_num = A7_ARE_NO_CHANGE
  difficulty = A7_ARE_NO_CHANGE
  duration = A7_ARE_NO_CHANGE
  wander_distance = A7_ARE_NO_CHANGE
  follow_distance = A7_ARE_NO_CHANGE
  max_num = A7_ARE_NO_CHANGE
  enable = A7_ARE_NO_CHANGE
  day_prob = A7_ARE_NO_CHANGE
  night_prob = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  name = ~?~
  cre_resref0 = ~?~
  cre_resref1 = ~?~
  cre_resref2 = ~?~
  cre_resref3 = ~?~
  cre_resref4 = ~?~
  cre_resref5 = ~?~
  cre_resref6 = ~?~
  cre_resref7 = ~?~
  cre_resref8 = ~?~
  cre_resref9 = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~

  ACTION_IF (success) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 32) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 32 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_FOR (i = 0; i < 10; ++i) BEGIN
      OUTER_SPRINT param ~cre_resref%i%~
      OUTER_SPRINT string EVAL ~%%param%%~
      ACTION_IF (STRING_LENGTH ~%string%~ > 8) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: String of parameter "%param%" exceeds 8 characters.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~rest~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%name%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x00 ~%name%~ (32) END
      FOR (i = 0; i < 10; ++i) BEGIN
        SET value = EVAL ~cre_strref%i%~
        PATCH_IF (value != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG (0x20 + i * 4) value END
        SPRINT resref EVAL ~%cre_resref%i%%~
        PATCH_IF (NOT ~%resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE (0x48 + i * 8) ~%resref%~ (8) END
      END
      PATCH_IF (spawn_num != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x98 spawn_num END
      PATCH_IF (difficulty != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x9a difficulty END
      PATCH_IF (duration != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x9c duration END
      PATCH_IF (wander_distance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xa0 wander_distance END
      PATCH_IF (follow_distance != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xa2 follow_distance END
      PATCH_IF (max_num != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xa4 max_num END
      PATCH_IF (enable != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xa6 (enable != 0) END
      PATCH_IF (day_prob != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xa8 day_prob END
      PATCH_IF (night_prob != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0xaa night_prob END
    END
    OUTER_SPRINT $~%are%~(~rest~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new automap note to the ARE handle.
 *
 * INT_VAR loc_x          X coordinate of the automap note. (Default: 0)
 * INT_VAR loc_y          Y coordinate of the automap note. (Default: 0)
 * INT_VAR note_strref    (All except PST) Strref of the note. (Default: -1)
 * INT_VAR strref_loc     (All except PST) Strref location (0=talk override, 1=dialog.tlk). (Default: 1)
 * INT_VAR color          Map marker color (PST: 0=blue, 1=red; everything else: 0-7). See MAPNOTES.IDS in EE games. (Default: 0)
 * INT_VAR note_id        (All except PST) Internal note ID. (Default: 0)
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR note_text      (PST only) Text of the automap note. May not be longer than 500 characters. (Default: empty string)
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET index              Returns the index of the added automap note structure if successful, -1 otherwise
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_automap
INT_VAR
  loc_x = 0
  loc_y = 0
  note_strref = "-1"
  strref_loc = 1
  color = 0
  note_id = 0
  silent = 0
STR_VAR
  are = ~are~
  note_text = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_notes = $~%are%~(~automap~)

  // validating PST text
  ACTION_IF (success && is_pst) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 500) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 500 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      PATCH_IF (is_v1 && is_pst) BEGIN
        INSERT_BYTES 0 532
        WRITE_LONG 0x00 loc_x
        WRITE_LONG 0x04 loc_y
        SPRINT $~%are%~(~automap~ ~%num_notes%~ ~text~) ~%note_text%~
        WRITE_ASCIIE 0x08 ~%note_text%~ (500)
        WRITE_LONG 0x1fc (color != 0)
      END ELSE BEGIN
        INSERT_BYTES 0 52
        WRITE_SHORT 0x00 loc_x
        WRITE_SHORT 0x02 loc_y
        SET $~%are%~(~automap~ ~%num_notes%~ ~text~) = note_strref
        WRITE_LONG 0x04 note_strref
        SET $~%are%~(~automap~ ~%num_notes%~ ~is_tlk~) = (strref_loc != 0)
        WRITE_SHORT 0x08 (strref_loc != 0)
        WRITE_SHORT 0x0a color
        WRITE_LONG 0x0c note_id
      END
    END
    OUTER_SPRINT $~%are%~(~automap~ ~%num_notes%~) ~%buffer%~
    OUTER_SET $~%are%~(~automap~) += 1
    OUTER_SET index = num_notes
  END
END

/**
 * Action and patch function that alters attributes of an existing automap note structure on the ARE handle.
 *
 * INT_VAR automap_index    Index of the automap note structure to patch.
 * INT_VAR loc_x            New X coordinate of the automap note. (Default: no change)
 * INT_VAR loc_y            New Y coordinate of the automap note. (Default: no change)
 * INT_VAR note_strref      (All except PST) New strref of the note. (Default: no change)
 * INT_VAR strref_loc       (All except PST) New strref location (0=talk override, 1=dialog.tlk). (Default: no change)
 * INT_VAR color            New map marker color (PST: 0=blue, 1=red; everything else: 0-7). (Default: no change)
 * INT_VAR note_id          (All except PST) New internal note ID. (Default: no change)
 * INT_VAR silent           Specify 1 to suppress any feedback messages. (Default: no change)
 * STR_VAR are              Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                          Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR note_text        (PST only) New text of the automap note. May not be longer than 500 characters. (Default: no change)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%          Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                          (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_automap
INT_VAR
  automap_index = "-1"
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  note_strref = A7_ARE_NO_CHANGE
  strref_loc = A7_ARE_NO_CHANGE
  color = A7_ARE_NO_CHANGE
  note_id = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  note_text = ~?~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_notes = $~%are%~(~automap~)

  ACTION_IF (success && (automap_index < 0 || automap_index >= num_notes)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Automap notes index is out of bounds: %automap_index%~
    END
  END

  // validating PST text
  ACTION_IF (success && is_pst) BEGIN
    ACTION_IF (STRING_LENGTH ~%name%~ > 500) BEGIN
      LAF SUBSTRING INT_VAR start = 0 length = 500 STR_VAR string = EVAL ~%name%~ RET name = substring END
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: String of parameter "name" is too long. Removing excess characters.~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~automap~ ~%automap_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (is_v1 && is_pst) BEGIN
        PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x00 loc_x END
        PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x04 loc_y END
        PATCH_IF (NOT ~%note_text%~ STR_EQ ~?~) BEGIN
          SPRINT $~%are%~(~automap~ ~%automap_index%~ ~text~) ~%note_text%~
          WRITE_ASCIIE 0x08 ~%note_text%~ (500)
        END
        PATCH_IF (color != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x1fc (color != 0) END
      END ELSE BEGIN
        PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x00 loc_x END
        PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x02 loc_y END
        PATCH_IF (note_strref != A7_ARE_NO_CHANGE) BEGIN
          SET $~%are%~(~automap~ ~%automap_index%~ ~text~) = note_strref
          WRITE_LONG 0x04 note_strref
        END
        PATCH_IF (strref_loc != A7_ARE_NO_CHANGE) BEGIN
          SET $~%are%~(~automap~ ~is_tlk~) = (strref_loc != 0)
          WRITE_SHORT 0x08 (strref_loc != 0)
        END
        PATCH_IF (color != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x0a color END
        PATCH_IF (note_id != A7_ARE_NO_CHANGE) BEGIN WRITE_LONG 0x0c note_id END
      END
    END
    OUTER_SPRINT $~%are%~(~automap~ ~%automap_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that removes an existing automap note structure from the ARE handle.
 *
 * INT_VAR automap_index  Index of the automap note structure to remove.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_automap
INT_VAR
  automap_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_notes = $~%are%~(~automap~)

  ACTION_IF (success && (automap_index < 0 || automap_index >= num_notes)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Automap notes index is out of bounds: %automap_index%~
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_FOR (idx = automap_index + 1; idx < num_notes; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~automap~ ~%prev_idx%~) $~%are%~(~automap~ ~%idx%~)
      ACTION_IF (is_v1 && is_pst) BEGIN
        OUTER_SPRINT $~%are%~(~automap~ ~%prev_idx%~ ~text~) $~%are%~(~automap~ ~%idx%~ ~text~)
      END ELSE BEGIN
        OUTER_SET $~%are%~(~automap~ ~%prev_idx%~ ~is_tlk~) = $~%are%~(~automap~ ~%idx%~ ~is_tlk~)
        OUTER_SET $~%are%~(~automap~ ~%prev_idx%~ ~text~) = $~%are%~(~automap~ ~%idx%~ ~text~)
      END
    END
    OUTER_SET $~%are%~(~automap~) = num_notes - 1
  END
END

/**
 * Action and patch function that moves the position of a automap note on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR automap_index  Index of the automap note structure to move.
 * INT_VAR x              Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y              Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%        Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                        (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_automap
INT_VAR
  automap_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET num_notes = $~%are%~(~automap~)

  ACTION_IF (success && (automap_index < 0 || automap_index >= num_notes)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Automap notes index is out of bounds: %automap_index%~
    END
  END

  ACTION_IF (success && (x != 0 || y != 0)) BEGIN
    OUTER_SPRINT buffer $~%are%~(~automap~ ~%automap_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (is_v1 && is_pst) BEGIN
        WRITE_LONG 0x00 (THIS + x)
        WRITE_LONG 0x04 (THIS + y)
      END ELSE BEGIN
        WRITE_SHORT 0x00 (THIS + x)
        WRITE_SHORT 0x02 (THIS + y)
      END
    END
    OUTER_SPRINT $~%are%~(~automap~ ~%automap_index%~) ~%buffer%~
  END
END

/**
 * Action and patch function that adds a new projectile trap to the ARE handle.
 * Note: This function works only on AREA V1.0 areas in BG2 or the EE games.
 *
 * INT_VAR missile_num          MISSILE.IDS reference of the projectile. (Default: 0)
 * INT_VAR frequency            Explosion length in frames. (Default: 0)
 * INT_VAR duration             Number of explosions. (Default: 1)
 * INT_VAR loc_x                X coordinate of the projectile trap. (Default: 0)
 * INT_VAR loc_y                Y coordinate of the projectile trap. (Default: 0)
 * INT_VAR loc_z                Height of the projectile trap. (Default: 0)
 * INT_VAR target               EA.IDS value of the target. (Default: 200 / EVILCUTOFF)
 * INT_VAR creator              Zero-based index of the party member who created the projectile (0-5). (Default: 0)
 * INT_VAR num_embedded_eff     Number of EFF structures to add. (Default: 0)
 * INT_VAR silent               Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                  Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                              Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR pro_resref           Resref of the projectile. (Default: empty string)
 * STR_VAR embedded_eff_0, ...  Array "embedded_eff" with "num_embedded_eff" effect entries. Each entry is either a path/to/v2.eff file
 *                              or an EFF resref. Alternate notation: $embedded_eff("0")
 * RET success                  Returns 1 if the operation was successful, 0 otherwise.
 * RET index                    Returns the index of the added projectile trap structure if successful, -1 otherwise
 * RET_ARRAY %are%              Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                              (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_add_projectile
INT_VAR
  missile_num = 0
  frequency = 0
  duration = 1
  loc_x = 0
  loc_y = 0
  loc_z = 0
  target = 200
  creator = 0
  num_embedded_eff = 0
  silent = 0
STR_VAR
  are = ~are~
  pro_resref = ~~
  // embedded_eff_0 = ~~
RET
  success
  index
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET index = "-1"
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET success = is_v1 && (is_bg2 || is_ee)
  OUTER_SET num_projectiles = $~%are%~(~projectile~)

  // validating resref
  ACTION_IF (success && STRING_LENGTH ~%pro_resref%~ > 8) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: String of parameter "pro_resref" exceeds 8 characters.~
    END
  END

  // validating EFF entries
  ACTION_IF (success && num_embedded_eff > 0) BEGIN
    OUTER_FOR (idx = 0; success && idx < num_embedded_eff; ++idx) BEGIN
      OUTER_SET success = VARIABLE_IS_SET $embedded_eff(~%idx%~)
      ACTION_IF (success) BEGIN
        OUTER_SPRINT entry $embedded_eff(~%idx%~)
        ACTION_IF (~%entry%~ STRING_MATCHES_REGEXP ~^.+\.eff$~ == 0) BEGIN
          OUTER_SET success = FILE_EXISTS ~%entry%~ && (SIZE_OF_FILE ~%entry%~ == 272)
        END ELSE BEGIN
          OUTER_SET success = FILE_EXISTS_IN_GAME ~%entry%.EFF~
        END
        ACTION_IF (NOT success && NOT silent) BEGIN
          WARN ~WARNING: EFF file or resource defined by "embedded_eff_%idx%" does not exist.~
        END
      END ELSE ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Not enough EFF entries defined (expected: %num_embedded_eff%, found: %idx%)~
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_PATCH_SAVE buffer ~~ BEGIN
      INSERT_BYTES 0 28

      WRITE_ASCIIE 0x00 ~%pro_resref%~ (8)
      WRITE_SHORT 0x0e missile_num
      WRITE_SHORT 0x10 frequency
      WRITE_SHORT 0x12 duration
      WRITE_SHORT 0x14 loc_x
      WRITE_SHORT 0x16 loc_y
      WRITE_SHORT 0x18 loc_z
      WRITE_BYTE 0x1a target
      WRITE_BYTE 0x1b creator
    END
    OUTER_SPRINT $~%are%~(~projectile~ ~%num_projectiles%~) ~%buffer%~

    // adding EFF entries
    OUTER_FOR (idx = 0; idx < num_embedded_eff; ++idx) BEGIN
      OUTER_SPRINT entry $embedded_eff(~%idx%~)
      OUTER_SET is_silent = IS_SILENT
      ACTION_IF (NOT is_silent) BEGIN SILENT END
      ACTION_IF (~%entry%~ STRING_MATCHES_REGEXP ~^.+\.eff$~ == 0) BEGIN
        // file path
        COPY ~%entry%~ ~%entry%~
          READ_ASCII 0x08 buffer (264)
        BUT_ONLY
      END ELSE BEGIN
        // resref
        COPY_EXISTING ~%entry%.EFF~ ~override~
          READ_ASCII 0x08 buffer (264)
        BUT_ONLY
      END
      ACTION_IF (NOT is_silent) BEGIN VERBOSE END

      OUTER_SPRINT $~%are%~(~projectile~ ~%num_projectiles%~ ~effect~ ~%idx%~) ~%buffer%~
    END
    OUTER_SET $~%are%~(~projectile~ ~%num_projectiles%~ ~effect~) = num_embedded_eff

    OUTER_SET $~%are%~(~projectile~) += 1
    OUTER_SET index = num_projectiles
  END
END

/**
 * Action and patch function that alters attributes of an existing projectile trap structure on the ARE handle.
 *
 * INT_VAR projectile_index     Index of the projectile trap structure to patch.
 * INT_VAR missile_num          New MISSILE.IDS reference of the projectile. (Default: no change)
 * INT_VAR frequency            Ne explosion length in frames. (Default: no change)
 * INT_VAR duration             New number of explosions. (Default: no change)
 * INT_VAR loc_x                New X coordinate of the projectile trap. (Default: no change)
 * INT_VAR loc_y                New Y coordinate of the projectile trap. (Default: no change)
 * INT_VAR loc_z                New height of the projectile trap. (Default: no change)
 * INT_VAR target               New EA.IDS value of the target. (Default: no change)
 * INT_VAR creator              New Zero-based index of the party member who created the projectile (0-5). (Default: no change)
 * INT_VAR num_embedded_eff     Number of EFF structures to patch. (Default: no change)
 * INT_VAR silent               Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                  Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                              Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR pro_resref           New resref of the projectile. (Default: no change)
 * STR_VAR embedded_eff_0, ...  Array "embedded_eff" with "num_embedded_eff" effect entries. Each entry is either a path/to/v2.eff file
 *                              or an EFF resref. Alternate notation: $embedded_eff("0")
 *                              Skip entries or assign an empty string to keep the original effect entry.
 *                              Skipping definitions or using an empty string for non-existing effect entries will trigger an error.
 *                              This array is only considered if "num_embedded_eff" is defined.
 * RET success                  Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%              Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                              (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_alter_projectile
INT_VAR
  projectile_index = "-1"
  missile_num = A7_ARE_NO_CHANGE
  frequency = A7_ARE_NO_CHANGE
  duration = A7_ARE_NO_CHANGE
  loc_x = A7_ARE_NO_CHANGE
  loc_y = A7_ARE_NO_CHANGE
  loc_z = A7_ARE_NO_CHANGE
  target = A7_ARE_NO_CHANGE
  creator = A7_ARE_NO_CHANGE
  num_embedded_eff = A7_ARE_NO_CHANGE
  silent = 0
STR_VAR
  are = ~are~
  pro_resref = ~?~
  // embedded_eff_0 = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET success = is_v1 && (is_bg2 || is_ee)
  OUTER_SET num_projectiles = $~%are%~(~projectile~)

  ACTION_IF (success && (projectile_index < 0 || projectile_index >= num_projectiles)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Projectile trap index is out of bounds: %projectile_index%~
    END
  END

  // validating resref
  ACTION_IF (success && STRING_LENGTH ~%pro_resref%~ > 8) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: String of parameter "pro_resref" exceeds 8 characters.~
    END
  END

  // validating EFF entries
  ACTION_IF (success && num_embedded_eff != A7_ARE_NO_CHANGE) BEGIN
    OUTER_SET num_entries_old = $~%are%~(~projectile~ ~%projectile_index%~ ~effect~)
    OUTER_FOR (idx = 0; success && idx < num_embedded_eff; ++idx) BEGIN
      ACTION_IF (NOT VARIABLE_IS_SET $embedded_eff(~%idx%~)) BEGIN
        // check if entry can be skipped
        ACTION_IF (idx < num_entries_old) BEGIN
          OUTER_SPRINT $embedded_eff(~%idx%~) ~~  // mark as "no change"
        END ELSE BEGIN
          OUTER_SET success = 0
          ACTION_IF (NOT silent) BEGIN
            WARN ~WARNING: Not enough effect entries defined (expected: %num_embedded_eff%, found: %idx%)~
          END
        END
      END ELSE BEGIN
        // validating defined entry
        OUTER_SPRINT entry $embedded_eff(~%idx%~)
        ACTION_IF (~%entry%~ STRING_MATCHES_REGEXP ~^.+\.eff$~ == 0) BEGIN
          OUTER_SET success = FILE_EXISTS ~%entry%~ && (SIZE_OF_FILE ~%entry%~ == 272)
        END ELSE BEGIN
          OUTER_SET success = FILE_EXISTS_IN_GAME ~%entry%.EFF~
        END
        ACTION_IF (NOT success && NOT silent) BEGIN
          WARN ~WARNING: EFF file or resource defined by "embedded_eff_%idx%" does not exist.~
        END
      END
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~projectile~ ~%projectile_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      PATCH_IF (NOT ~%pro_resref%~ STR_EQ ~?~) BEGIN WRITE_ASCIIE 0x00 ~%pro_resref%~ (8) END
      PATCH_IF (missile_num != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x0e missile_num END
      PATCH_IF (frequency != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x10 frequency END
      PATCH_IF (duration != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x12 duration END
      PATCH_IF (loc_x != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x14 loc_x END
      PATCH_IF (loc_y != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x16 loc_y END
      PATCH_IF (loc_z != A7_ARE_NO_CHANGE) BEGIN WRITE_SHORT 0x18 loc_z END
      PATCH_IF (target != A7_ARE_NO_CHANGE) BEGIN WRITE_BYTE 0x1a target END
      PATCH_IF (creator != A7_ARE_NO_CHANGE) BEGIN WRITE_BYTE 0x1b creator END
    END
    OUTER_SPRINT $~%are%~(~projectile~ ~%projectile_index%~) ~%buffer%~

    // patching effects
    ACTION_IF (num_embedded_eff != A7_ARE_NO_CHANGE) BEGIN
      OUTER_FOR (idx = 0; idx < num_embedded_eff; ++idx) BEGIN
        OUTER_SPRINT entry $embedded_eff(~%idx%~)
        ACTION_IF (NOT ~%entry%~ STR_EQ ~~) BEGIN
          OUTER_SET is_silent = IS_SILENT
          ACTION_IF (NOT is_silent) BEGIN SILENT END
          ACTION_IF (~%entry%~ STRING_MATCHES_REGEXP ~^.+\.eff$~ == 0) BEGIN
            // file path
            COPY ~%entry%~ ~%entry%~
              READ_ASCII 0x08 buffer (264)
            BUT_ONLY
          END ELSE BEGIN
            // resref
            COPY_EXISTING ~%entry%.EFF~ ~override~
              READ_ASCII 0x08 buffer (264)
            BUT_ONLY
          END
          ACTION_IF (NOT is_silent) BEGIN VERBOSE END
          OUTER_SPRINT $~%are%~(~projectile~ ~%projectile_index%~ ~effect~ ~%idx%~) ~%buffer%~
        END
      END
      OUTER_SET $~%are%~(~projectile~ ~%num_projectiles%~ ~effect~) = num_embedded_eff
    END
  END
END

/**
 * Action and patch function that removes an existing projectile trap structure from the ARE handle.
 *
 * INT_VAR projectile_index   Index of the projectile trap structure to remove.
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_remove_projectile
INT_VAR
  projectile_index = "-1"
  silent = 0
STR_VAR
  are = ~are~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET success = is_v1 && (is_bg2 || is_ee)
  OUTER_SET num_projectiles = $~%are%~(~projectile~)

  ACTION_IF (success && (projectile_index < 0 || projectile_index >= num_projectiles)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Projectile trap index is out of bounds: %projectile_index%~
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_FOR (idx = projectile_index + 1; idx < num_projectiles; ++idx) BEGIN
      OUTER_SET prev_idx = idx - 1
      OUTER_SPRINT $~%are%~(~projectile~ ~%prev_idx%~) $~%are%~(~projectile~ ~%idx%~)

      // effects list
      OUTER_SET num_eff = $~%are%~(~projectile~ ~%idx%~ ~effect~)
      OUTER_FOR (idx2 = 0; idx2 < num_eff; ++idx2) BEGIN
        OUTER_SPRINT $~%are%~(~projectile~ ~%prev_idx%~ ~effect~ ~%idx2%~) $~%are%~(~projectile~ ~%idx%~ ~effect~ ~%idx2%~)
      END
      OUTER_SET $~%are%~(~projectile~ ~%prev_idx%~ ~effect~) = num_eff
    END
    OUTER_SET $~%are%~(~projectile~) = num_projectiles - 1
  END
END

/**
 * Action and patch function that moves the position of a projectile trap on the ARE handle by a specified amount in either direction.
 * 
 * INT_VAR projectile_index   Index of the projectile trap structure to move.
 * INT_VAR x                  Amount to move in horizontal direction. Specify positive values to move to the right and negative values to move to the left.
 * INT_VAR y                  Amount to move in vertical direction. Specify positive values to move downwards and negative values to move upwards.
 * INT_VAR silent             Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are                Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                            Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 * RET_ARRAY %are%            Returns the updated ARE handle. Specify the actual name of the ARE handle that is returned by "a7#are_open"
 *                            (which is "are" by default).
 */
DEFINE_DIMORPHIC_FUNCTION a7#batch_are_move_projectile
INT_VAR
  projectile_index = "-1"
  x = 0
  y = 0
  silent = 0
STR_VAR
  are = ~are~
  region_name = ~~
RET
  success
RET_ARRAY
  ~%are%~
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET success = is_v1 && (is_bg2 || is_ee)
  OUTER_SET num_projectiles = $~%are%~(~projectile~)

  ACTION_IF (success && (projectile_index < 0 || projectile_index >= num_projectiles)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Projectile trap index is out of bounds: %projectile_index%~
    END
  END

  ACTION_IF (success) BEGIN
    OUTER_SPRINT buffer $~%are%~(~projectile~ ~%projectile_index%~)
    OUTER_PATCH_SAVE buffer ~%buffer%~ BEGIN
      WRITE_SHORT 0x14 (THIS + x)
      WRITE_SHORT 0x16 (THIS + y)
    END
    OUTER_SPRINT $~%are%~(~projectile~ ~%projectile_index%~) ~%buffer%~
  END
END


/**
 * Used internally: Calculates the size of the "explored bitmap" buffer.
 *
 * STR_VAR are        Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                    Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * RET size           Size of the explored bitmap, in bytes. Returns 0 if the size could not be determined.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__calculate_explored_size
STR_VAR
  are = ~are~
RET
  size
BEGIN
  LAF a7#__are_validate STR_VAR are RET success END
  OUTER_SET size = 0

  ACTION_IF (success) BEGIN
    OUTER_SPRINT wed_resref $~%are%~(~wed_resref~)
    ACTION_IF (NOT ~%wed_resref%~ STR_EQ ~~ && FILE_EXISTS_IN_GAME ~%wed_resref%.wed~) BEGIN
      OUTER_SET is_silent = IS_SILENT
      ACTION_IF (NOT is_silent) BEGIN SILENT END
      COPY_EXISTING ~%wed_resref%.wed~ ~override~
        READ_LONG 0x08 num_ovl
        READ_LONG 0x10 ofs_ovl
        PATCH_IF (num_ovl > 0) BEGIN
          READ_SHORT (ofs_ovl + 0x00) tiles_width
          READ_SHORT (ofs_ovl + 0x02) tiles_height
          SET extra = (GAME_IS ~bg1 totsc pst~) ? 0 : 1
          SET bits = ((tiles_width * 2) + extra) * ((tiles_height * 2) + extra)
          SET rem = (bits & 7) != 0
          SET size = bits / 8 + rem
        END
      BUT_ONLY
      ACTION_IF (NOT is_silent) BEGIN VERBOSE END
    END
  END
END

/**
 * Used internally: Calculates the anchor point for the scale operation.
 *
 * INT_VAR min_x    Left-most coordinate of the polygon.
 * INT_VAR min_y    Top-most coordinate of the polygon.
 * INT_VAR max_x    Right-most coordinate of the polygon.
 * INT_VAR max_y    Bottom-most coordinate of the polygon.
 * INT_VAR x        X coordinate for a custom anchor.
 * INT_VAR y        Y coordinate for a custom anchor.
 * INT_VAR silent   Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR anchor   Anchor point for the scaling operation.
 * RET success      Returns 1 if the operation was successful, 0 otherwise.
 * RET x            X coordinate of the anchor point.
 * RET y            Y coordinate of the anchor point.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__get_scale_anchor
INT_VAR
  min_x = 0
  min_y = 0
  max_x = 0
  max_y = 0
  x = 0
  y = 0
  silent = 0
STR_VAR
  anchor = ~origin~
RET
  success
  x
  y
BEGIN
  OUTER_SET success = 1
  ACTION_MATCH ~%anchor%~ WITH
    ~origin~ BEGIN
      OUTER_SET x = 0
      OUTER_SET y = 0
    END
    ~custom~ BEGIN
      // use x and y as specified
    END
    ~relative_top_left~ BEGIN
      OUTER_SET x = min_x
      OUTER_SET y = min_y
    END
    ~relative_top_center~ BEGIN
      OUTER_SET x = (min_x + max_x) / 2
      OUTER_SET y = min_y
    END
    ~relative_top_right~ BEGIN
      OUTER_SET x = max_x
      OUTER_SET y = min_y
    END
    ~relative_center_left~ BEGIN
      OUTER_SET x = min_x
      OUTER_SET y = (min_y + max_y) / 2
    END
    ~relative_center_right~ BEGIN
      OUTER_SET x = max_x
      OUTER_SET y = (min_y + max_y) / 2
    END
    ~relative_bottom_left~ BEGIN
      OUTER_SET x = min_x
      OUTER_SET y = max_y
    END
    ~relative_bottom_center~ BEGIN
      OUTER_SET x = (min_x + max_x) / 2
      OUTER_SET y = max_y
    END
    ~relative_bottom_right~ BEGIN
      OUTER_SET x = max_x
      OUTER_SET y = max_y
    END
    ~relative_center~ BEGIN
      OUTER_SET x = (min_x + max_x) / 2
      OUTER_SET y = (min_y + max_y) / 2
    END
    DEFAULT
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: Unsupported anchor type: %anchor%~
      END
  END
END

/**
 * Used internally: Scales a single coordinate relative to an anchor point.
 *
 * INT_VAR value        Coordinate to scale.
 * INT_VAR anchor       Anchor coordinate.
 * INT_VAR numerator    Numerator of the scaling factor.
 * INT_VAR denominator  Denominator of the scaling factor. Must not be 0.
 * RET value            The scaled coordinate.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__scale_coordinate
INT_VAR
  value = 0
  anchor = 0
  numerator = 1
  denominator = 1
RET
  value
BEGIN
  ACTION_IF (denominator != 0) BEGIN
    OUTER_SET value = ((value - anchor) * numerator / denominator) + anchor
    OUTER_SET value = (value < 0) ? "-1" : value
  END
END

/**
 * Used internally: Returns embedded CRE data based on the given parameters.
 *
 * INT_VAR index          Actor structure index.
 * INT_VAR silent         Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are            Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 *                        Can be omitted if the return value from "a7#are_open" is used as is. (Default: "are")
 * STR_VAR cre_resref     Optional CRE resref that is used as return value for "cre_buffer_res".
 * STR_VAR cre_embedded   Embedded CRE as data string, full path to the CRE file, or resref of the CRE resource.
 * RET success            Returns 1 if the operation was successful, 0 otherwise.
 * RET is_cre_buffer      Returns 1 if a CRE buffer is loaded.
 * RET cre_buffer         Returns CRE data as string.
 * RET cre_buffer_res     Returns CRE resref as string.
 * RET cre_buffer_name    Returns name of the creature stored in the CRE file as string.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_actor_get_embedded_cre
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  cre_resref = ~~
  cre_embedded = ~~
RET
  success
  is_cre_buffer
  cre_buffer
  cre_buffer_res
  cre_buffer_name
BEGIN
  OUTER_SET success = (NOT ~%are%~ STR_EQ ~~ && index >= 0)
  OUTER_SET is_cre_buffer = 0
  OUTER_SPRINT cre_buffer ~~
  OUTER_SPRINT cre_buffer_res ~~
  OUTER_SPRINT cre_buffer_name ~~

  ACTION_IF (success) BEGIN
    // check if "cre_embedded" contains CRE data
    OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
    OUTER_SET min_cre_size = is_v1 ? 656 : 672
    ACTION_IF (STRING_LENGTH ~%cre_embedded%~ >= min_cre_size) BEGIN
      OUTER_PATCH ~%cre_embedded%~ BEGIN READ_ASCII 0 sig (8) READ_STRREF NAME1 cre_buffer_name END
      ACTION_IF ((is_v1 && ~%sig%~ STR_EQ ~CRE V1.0~) || (NOT is_v1 && ~%ver%~ STR_EQ ~CRE V2.2~)) BEGIN
        OUTER_SET is_cre_buffer = 1
        OUTER_SPRINT cre_buffer ~%cre_embedded%~
        ACTION_IF (NOT ~%cre_resref%~ STR_EQ ~~) BEGIN
          OUTER_SPRINT cre_buffer_res ~%cre_resref%~
        END ELSE BEGIN
          ACTION_IF (index < 1000) BEGIN
            OUTER_SPRINT cre_buffer_res ~ACTOR%index%~
          END ELSE ACTION_IF (index < 10000) BEGIN
            OUTER_SPRINT cre_buffer_res ~ACTR%index%~
          END ELSE BEGIN
            OUTER_SPRINT cre_buffer_res ~ACT%index%~
          END
        END
      END
    END

    ACTION_IF (NOT is_cre_buffer && ~%cre_embedded%~ STRING_MATCHES_REGEXP ~^.+\.cre$~ == 0) BEGIN
      // treat as path
      ACTION_IF (FILE_EXISTS ~%cre_embedded%~) BEGIN
        OUTER_SET is_silent = IS_SILENT
        ACTION_IF (NOT is_silent) BEGIN SILENT END
        COPY ~%cre_embedded%~ ~%cre_embedded%~
          READ_ASCII 0 cre_buffer (BUFFER_LENGTH)
          READ_STRREF NAME1 cre_buffer_name
          SPRINT cre_buffer_res ~%SOURCE_RES%~
        BUT_ONLY
        ACTION_IF (NOT is_silent) BEGIN VERBOSE END
        OUTER_SET is_cre_buffer = 1
      END ELSE BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: CRE file specified by "cre_embedded" parameter does not exist.~
        END
      END
    END ELSE ACTION_IF (NOT is_cre_buffer && NOT ~%cre_embedded%~ STR_EQ ~~) BEGIN
      // treat as resref
      ACTION_IF (FILE_EXISTS_IN_GAME ~%cre_embedded%.cre~) BEGIN
        OUTER_SET is_silent = IS_SILENT
        ACTION_IF (NOT is_silent) BEGIN SILENT END
        COPY_EXISTING ~%cre_embedded%.cre~ ~override~
          READ_ASCII 0 cre_buffer (BUFFER_LENGTH)
          READ_STRREF NAME1 cre_buffer_name
          SPRINT cre_buffer_res ~%SOURCE_RES%~
        BUT_ONLY
        ACTION_IF (NOT is_silent) BEGIN VERBOSE END
        OUTER_SET is_cre_buffer = 1
      END ELSE BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: CRE resref specified by "cre_embedded" parameter does not exist.~
        END
      END
    END ELSE ACTION_IF (NOT is_cre_buffer) BEGIN
      // fail
      OUTER_SET success = 0
      ACTION_IF (NOT silent) BEGIN
        WARN ~WARNING: "cre_embedded" parameter not specified.~
      END
    END
  END
END

/**
 * Used internally: Returns information about the current game.
 *
 * RET is_bg      Whether the current game is oBG (with or without TotSC).
 * RET is_bg2     Whether the current game is oBG2 (with or without ToB; includes Tutu and BGT).
 * RET is_iwd     Whether the current game is oIWD (with or without HoW/TotLM).
 * RET is_iwd2    Whether the current game is IWD2.
 * RET is_pst     Whether the current game is oPST.
 * RET is_ee      Whether the current game is any of the EE games (BGEE, BG2EE, IWDEE, PSTEE).
 * RET is_pstee   Whether the current game is PSTEE.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_get_engine
RET
  is_bg
  is_bg2
  is_iwd
  is_iwd2
  is_pst
  is_ee
  is_pstee
BEGIN
  OUTER_SET is_bg = ENGINE_IS ~bg1 totsc~
  OUTER_SET is_bg2 = ENGINE_IS ~soa tob~
  OUTER_SET is_iwd = ENGINE_IS ~iwd how totlm~
  OUTER_SET is_iwd2 = ENGINE_IS ~iwd2~
  OUTER_SET is_pst = ENGINE_IS ~pst~
  OUTER_SET is_ee = GAME_IS ~bgee bg2ee iwdee pstee eet~
  OUTER_SET is_pstee = GAME_IS ~pstee~
END

/**
 * Used internally: Disassembles the current ARE into the array structure "are".
 *
 * RET success    Returns 1 on success and 0 on error.
 * RET_ARRAY are  Initialized ARE array structure if success is 1.
 */
DEFINE_PATCH_FUNCTION a7#__are_disassemble
RET
  success
RET_ARRAY
  are
BEGIN
  SET success = 1

  SPRINT $are(~version~) ~~
  SET $are(~actor~) = 0
  SET $are(~region~) = 0
  SET $are(~spawnpoint~) = 0
  SET $are(~entrance~) = 0
  SET $are(~container~) = 0
  SET $are(~ambient~) = 0
  SET $are(~variable~) = 0
  SPRINT $are(~explored~) ~~
  SET $are(~door~) = 0
  SET $are(~animation~) = 0
  SET $are(~tiled~) = 0
  SPRINT $are(~songs~) ~~
  SPRINT $are(~rest~) ~~
  SET $are(~automap~) = 0
  SET $are(~projectile~) = 0

  READ_ASCII 0x00 sig (4)
  READ_ASCII 0x04 ver (4)

  PATCH_IF (NOT ~%sig%~ STR_EQ ~AREA~ || NOT (~%ver%~ STR_EQ ~V1.0~ || ~%ver%~ STR_EQ ~V9.1~)) BEGIN
    SET success = 0
  END

  PATCH_IF (success) BEGIN
    LPF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END
    SET is_v1 = ~%ver%~ STR_EQ ~V1.0~
    SET adjust = is_v1 ? 0 : 0x10

    // basic ARE attributes
    SPRINT $are(~version~) ~%ver%~
    READ_ASCII 0x08 value (8) NULL
    SPRINT $are(~wed_resref~) ~%value%~
    READ_LONG 0x10 value
    SET $are(~last_saved~) = value
    READ_LONG 0x14 value
    SET $are(~area_flags~) = value
    READ_ASCII 0x18 value (8) NULL
    SPRINT $are(~area_resref_north~) ~%value%~
    READ_LONG 0x20 value
    SET $are(~area_flags_north~) = value
    READ_ASCII 0x24 value (8) NULL
    SPRINT $are(~area_resref_east~) ~%value%~
    READ_LONG 0x2c value
    SET $are(~area_flags_east~) = value
    READ_ASCII 0x30 value (8) NULL
    SPRINT $are(~area_resref_south~) ~%value%~
    READ_LONG 0x38 value
    SET $are(~area_flags_south~) = value
    READ_ASCII 0x3c value (8) NULL
    SPRINT $are(~area_resref_west~) ~%value%~
    READ_LONG 0x44 value
    SET $are(~area_flags_west~) = value
    READ_SHORT 0x48 value
    SET $are(~area_type~) = value
    READ_SHORT 0x4a value
    SET $are(~probability_rain~) = value
    READ_SHORT 0x4c value
    SET $are(~probability_snow~) = value
    READ_SHORT 0x4e value
    SET $are(~probability_fog~) = value
    READ_SHORT 0x50 value
    SET $are(~probability_lightning~) = value
    READ_SHORT 0x52 value
    SET $are(~overlay_transparency~) = value
    PATCH_IF (is_v1) BEGIN
      SET $are(~area_difficulty_2~) = 0
      SET $are(~area_difficulty_3~) = 0
      SET $are(~area_difficulty_1~) = 0
    END ELSE BEGIN
      READ_BYTE 0x54 value
      SET $are(~area_difficulty_2~) = value
      READ_BYTE 0x55 value
      SET $are(~area_difficulty_3~) = value
      READ_SHORT 0x56 value
      SET $are(~area_difficulty_1~) = value
    END
    READ_ASCII (0x94 + adjust) value (8) NULL
    SPRINT $are(~area_script~) ~%value%~
    PATCH_IF (is_v1 && (is_bg2 || is_ee)) BEGIN
      READ_ASCII 0xd4 value (8) NULL
      SPRINT $are(~rest_movie_day~) ~%value%~
      READ_ASCII 0xdc value (8) NULL
      SPRINT $are(~rest_movie_night~) ~%value%~
    END ELSE BEGIN
      SPRINT $are(~rest_movie_day~) ~~
      SPRINT $are(~rest_movie_night~) ~~
    END

    READ_LONG (0x54 + adjust) ofs_actors
    READ_SHORT (0x58 + adjust) num_actors
    READ_SHORT (0x5a + adjust) num_regions
    READ_LONG (0x5c + adjust) ofs_regions
    READ_LONG (0x60 + adjust) ofs_spawns
    READ_LONG (0x64 + adjust) num_spawns
    READ_LONG (0x68 + adjust) ofs_entrances
    READ_LONG (0x6c + adjust) num_entrances
    READ_LONG (0x70 + adjust) ofs_containers
    READ_SHORT (0x74 + adjust) num_containers
    READ_SHORT (0x76 + adjust) num_items_total
    READ_LONG (0x78 + adjust) ofs_items
    READ_LONG (0x7c + adjust) ofs_vertices
    READ_SHORT (0x80 + adjust) num_vertices_total
    READ_SHORT (0x82 + adjust) num_ambients
    READ_LONG (0x84 + adjust) ofs_ambients
    READ_LONG (0x88 + adjust) ofs_variables
    READ_SHORT (0x8c + adjust) num_variables
    READ_LONG (0x9c + adjust) size_explored
    READ_LONG (0xa0 + adjust) ofs_explored
    READ_LONG (0xa4 + adjust) num_doors
    READ_LONG (0xa8 + adjust) ofs_doors
    READ_LONG (0xac + adjust) num_animations
    READ_LONG (0xb0 + adjust) ofs_animations
    READ_LONG (0xb4 + adjust) num_tiled
    READ_LONG (0xb8 + adjust) ofs_tiled
    READ_LONG (0xbc + adjust) ofs_songs
    READ_LONG (0xc0 + adjust) ofs_rest
    PATCH_IF (is_pst) BEGIN
      READ_LONG (0xc8 + adjust) ofs_notes
      READ_LONG (0xcc + adjust) num_notes
      SET ofs_projectiles = 0
      SET num_projectiles = 0
    END ELSE BEGIN
      READ_LONG (0xc4 + adjust) ofs_notes
      READ_LONG (0xc8 + adjust) num_notes
      PATCH_IF (is_bg2 || is_ee) BEGIN
        READ_LONG (0xcc + adjust) ofs_projectiles
        READ_LONG (0xd0 + adjust) num_projectiles
      END ELSE BEGIN
        SET ofs_projectiles = 0
        SET num_projectiles = 0
      END
    END

    // parsing actors
    PATCH_IF (ofs_actors > 0 && num_actors > 0) BEGIN
      SET $are(~actor~) = num_actors
      FOR (idx = 0; idx < num_actors; ++idx) BEGIN
        SET ofs = ofs_actors + (idx * 272)
        READ_ASCII ofs $are(~actor~ ~%idx%~) (272)
        READ_ASCII ofs $are(~actor~ ~%idx%~ ~name~) (32) NULL
        READ_LONG (ofs + 0x28) flags
        PATCH_IF (flags & BIT0) BEGIN
          // CRE not attached
          SET $are(~actor~ ~%idx%~ ~cre_attached~) = 0
        END ELSE BEGIN
          // CRE attached
          READ_LONG (ofs + 0x88) ofs_cre
          READ_LONG (ofs + 0x8c) size_cre
          READ_ASCII ofs_cre $are(~actor~ ~%idx%~ ~cre~) (size_cre)
          SET $are(~actor~ ~%idx%~ ~cre_attached~) = 1
        END
      END
    END

    // parsing regions
    PATCH_IF (ofs_regions > 0 && num_regions > 0) BEGIN
      SET $are(~region~) = num_regions
      FOR (idx_region = 0; idx_region < num_regions; ++idx_region) BEGIN
        SET cur_ofs_region = ofs_regions + (idx_region * 196)
        READ_ASCII cur_ofs_region $are(~region~ ~%idx_region%~) (196)
        READ_ASCII cur_ofs_region $are(~region~ ~%idx_region%~ ~name~) (32) NULL

        // parsing vertices
        READ_SHORT (cur_ofs_region + 0x2a) num_vertices
        READ_LONG (cur_ofs_region + 0x2c) idx_vertices
        SET $are(~region~ ~%idx_region%~ ~vertex~) = num_vertices
        FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
          READ_LONG (ofs_vertices + (idx_vertices + idx_vtx) * 4) xy
          SET $are(~region~ ~%idx_region%~ ~vertex~ ~%idx_vtx%~) = xy
        END
      END
    END

    // parsing spawn points
    PATCH_IF (ofs_spawns > 0 && num_spawns > 0) BEGIN
      SET $are(~spawnpoint~) = num_spawns
      FOR (idx = 0; idx < num_spawns; ++idx) BEGIN
        SET ofs = ofs_spawns + (idx * 200)
        READ_ASCII ofs $are(~spawnpoint~ ~%idx%~) (200)
        READ_ASCII ofs $are(~spawnpoint~ ~%idx%~ ~name~) (32) NULL
      END
    END

    // parsing entrances
    PATCH_IF (ofs_entrances > 0 && num_entrances > 0) BEGIN
      SET $are(~entrance~) = num_entrances
      FOR (idx = 0; idx < num_entrances; ++idx) BEGIN
        SET ofs = ofs_entrances + (idx * 104)
        READ_ASCII ofs $are(~entrance~ ~%idx%~) (104)
        READ_ASCII ofs $are(~entrance~ ~%idx%~ ~name~) (32) NULL
      END
    END

    // parsing containers
    PATCH_IF (ofs_containers > 0 && num_containers > 0) BEGIN
      SET $are(~container~) = num_containers
      FOR (idx_container = 0; idx_container < num_containers; ++idx_container) BEGIN
        SET cur_ofs_container = ofs_containers + (idx_container * 192)
        READ_ASCII cur_ofs_container $are(~container~ ~%idx_container%~) (192)
        READ_ASCII cur_ofs_container $are(~container~ ~%idx_container%~ ~name~) (32) NULL

        // parsing items
        READ_LONG (cur_ofs_container + 0x40) idx_items
        READ_LONG (cur_ofs_container + 0x44) num_items
        SET $are(~container~ ~%idx_container%~ ~item~) = num_items
        FOR (idx_item = 0; idx_item < num_items; ++idx_item) BEGIN
          SET cur_ofs_item = ofs_items + ((idx_items + idx_item) * 20)
          READ_ASCII cur_ofs_item $are(~container~ ~%idx_container%~ ~item~ ~%idx_item%~) (20)
          READ_ASCII cur_ofs_item $are(~container~ ~%idx_container%~ ~item~ ~%idx_item%~ ~resref~) (8) NULL
        END

        // parsing vertices
        READ_LONG (cur_ofs_container + 0x50) idx_vertices
        READ_SHORT (cur_ofs_container + 0x54) num_vertices
        SET $are(~container~ ~%idx_container%~ ~vertex~) = num_vertices
        FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
          READ_LONG (ofs_vertices + (idx_vertices + idx_vtx) * 4) xy
          SET $are(~container~ ~%idx_container%~ ~vertex~ ~%idx_vtx%~) = xy
        END
      END
    END

    // parsing ambient sounds
    PATCH_IF (ofs_ambients > 0 && num_ambients > 0) BEGIN
      SET $are(~ambient~) = num_ambients
      FOR (idx = 0; idx < num_ambients; ++idx) BEGIN
        SET ofs = ofs_ambients + (idx * 212)
        READ_ASCII ofs $are(~ambient~ ~%idx%~) (212)
        READ_ASCII ofs $are(~ambient~ ~%idx%~ ~name~) (32) NULL
      END
    END

    // parsing variables
    PATCH_IF (ofs_variables > 0 && num_variables > 0) BEGIN
      SET $are(~variable~) = num_variables
      FOR (idx = 0; idx < num_variables; ++idx) BEGIN
        SET ofs = ofs_variables + (idx * 84)
        READ_ASCII ofs $are(~variable~ ~%idx%~) (84)
        READ_ASCII ofs $are(~variable~ ~%idx%~ ~name~) (32) NULL
        READ_LONG (ofs + 0x28) value
        SET $are(~variable~ ~%idx%~ ~value~) = value
      END
    END

    // parsing explored bitmap
    PATCH_IF (ofs_explored > 0 && size_explored > 0) BEGIN
      READ_ASCII ofs_explored $are(~explored~) (size_explored)
    END

    // parsing doors
    PATCH_IF (ofs_doors > 0 && num_doors > 0) BEGIN
      SET $are(~door~) = num_doors
      FOR (idx_door = 0; idx_door < num_doors; ++idx_door) BEGIN
        SET cur_ofs_door = ofs_doors + (idx_door * 200)
        READ_ASCII cur_ofs_door $are(~door~ ~%idx_door%~) (200)
        READ_ASCII cur_ofs_door $are(~door~ ~%idx_door%~ ~name~) (32) NULL

        // parsing open vertices
        READ_LONG (cur_ofs_door + 0x2c) idx_vertices_open
        READ_SHORT (cur_ofs_door + 0x30) num_vertices_open
        SET $are(~door~ ~%idx_door%~ ~vertex_open~) = num_vertices_open
        FOR (idx_vtx = 0; idx_vtx < num_vertices_open; ++idx_vtx) BEGIN
          READ_LONG (ofs_vertices + (idx_vertices_open + idx_vtx) * 4) xy
          SET $are(~door~ ~%idx_door%~ ~vertex_open~ ~%idx_vtx%~) = xy
        END

        // parsing closed vertices
        READ_SHORT (cur_ofs_door + 0x32) num_vertices_closed
        READ_LONG (cur_ofs_door + 0x34) idx_vertices_closed
        SET $are(~door~ ~%idx_door%~ ~vertex_closed~) = num_vertices_closed
        FOR (idx_vtx = 0; idx_vtx < num_vertices_closed; ++idx_vtx) BEGIN
          READ_LONG (ofs_vertices + (idx_vertices_closed + idx_vtx) * 4) xy
          SET $are(~door~ ~%idx_door%~ ~vertex_closed~ ~%idx_vtx%~) = xy
        END

        // parsing open cells
        READ_LONG (cur_ofs_door + 0x48) idx_cells_open
        READ_SHORT (cur_ofs_door + 0x4c) num_cells_open
        SET $are(~door~ ~%idx_door%~ ~cell_open~) = num_cells_open
        FOR (idx_cell = 0; idx_cell < num_cells_open; ++idx_cell) BEGIN
          READ_LONG (ofs_vertices + (idx_cells_open + idx_cell) * 4) xy
          SET $are(~door~ ~%idx_door%~ ~cell_open~ ~%idx_cell%~) = xy
        END

        // parsing closed cells
        READ_SHORT (cur_ofs_door + 0x4e) num_cells_closed
        READ_LONG (cur_ofs_door + 0x50) idx_cells_closed
        SET $are(~door~ ~%idx_door%~ ~cell_closed~) = num_cells_closed
        FOR (idx_cell = 0; idx_cell < num_cells_closed; ++idx_cell) BEGIN
          READ_LONG (ofs_vertices + (idx_cells_closed + idx_cell) * 4) xy
          SET $are(~door~ ~%idx_door%~ ~cell_closed~ ~%idx_cell%~) = xy
        END
      END
    END

    // parsing animations
    PATCH_IF (ofs_animations > 0 && num_animations > 0) BEGIN
      SET $are(~animation~) = num_animations
      FOR (idx = 0; idx < num_animations; ++idx) BEGIN
        SET ofs = ofs_animations + (idx * 76)
        READ_ASCII ofs $are(~animation~ ~%idx%~) (76)
        READ_ASCII ofs $are(~animation~ ~%idx%~ ~name~) (32) NULL
      END
    END

    // parsing tiled objects
    PATCH_IF (ofs_tiled > 0 && num_tiled > 0) BEGIN
      SET $are(~tiled~) = num_tiled
      FOR (idx_tiled = 0; idx_tiled < num_tiled; ++idx_tiled) BEGIN
        SET cur_ofs_tiled = ofs_tiled + (idx_tiled * 104)
        READ_ASCII cur_ofs_tiled $are(~tiled~ ~%idx_tiled%~) (104)
        READ_ASCII cur_ofs_tiled $are(~tiled~ ~%idx_tiled%~ ~name~) (32) NULL

        // parsing open cells
        READ_LONG (cur_ofs_tiled + 0x2c) idx_cells_open
        READ_SHORT (cur_ofs_tiled + 0x30) num_cells_open
        SET $are(~tiled~ ~cell_open~) = num_cells_open
        FOR (idx_cell = 0; idx_cell < num_cells_open; ++idx_cell) BEGIN
          READ_LONG (ofs_vertices + (idx_cells_open + idx_cell) * 4) xy
          SET $are(~tiled~ ~cell_open~) = xy
        END

        // parsing closed cells
        READ_SHORT (cur_ofs_tiled + 0x32) num_cells_closed
        READ_LONG (cur_ofs_tiled + 0x34) idx_cells_closed
        SET $are(~tiled~ ~cell_closed~) = num_cells_closed
        FOR (idx_cell = 0; idx_cell < num_cells_closed; ++idx_cell) BEGIN
          READ_LONG (ofs_vertices + (idx_cells_closed + idx_cell) * 4) xy
          SET $are(~tiled~ ~cell_closed~) = xy
        END
      END
    END

    // parsing songs
    PATCH_IF (ofs_songs > 0) BEGIN
      READ_ASCII ofs_songs $are(~songs~) (144)
    END

    // parsing rest
    PATCH_IF (ofs_rest > 0) BEGIN
      READ_ASCII ofs_rest $are(~rest~) (228)
    END

    // parsing automap notes
    PATCH_IF (ofs_notes > 0 && num_notes > 0) BEGIN
      SET size_note = is_pst ? 532 : 52
      SET $are(~automap~) = num_notes
      FOR (idx = 0; idx < num_notes; ++idx) BEGIN
        SET ofs = ofs_notes + (idx * size_note)
        READ_ASCII ofs $are(~automap~ ~%idx%~) (size_note)
        PATCH_IF (is_pst) BEGIN
          READ_ASCII (ofs + 0x08) $are(~automap~ ~%idx%~ ~text~) (500) NULL
        END ELSE BEGIN
          READ_SHORT (ofs + 0x08) is_tlk  // 0=talk override, 1=dialog.tlk
          READ_LONG (ofs + 0x04) strref
          SET $are(~automap~ ~%idx%~ ~is_tlk~) = (is_tlk != 0)
          SET $are(~automap~ ~%idx%~ ~text~) = strref
        END
      END
    END

    // parsing projectile traps
    PATCH_IF (ofs_projectiles > 0 && num_projectiles > 0) BEGIN
      SET $are(~projectile~) = num_projectiles
      FOR (idx_pro = 0; idx_pro < num_projectiles; ++idx_pro) BEGIN
        SET cur_ofs_pro = ofs_projectiles + (idx_pro * 28)
        READ_ASCII cur_ofs_pro $are(~projectile~ ~%idx_pro%~) (28)

        // parsing projectile effects
        READ_LONG (cur_ofs_pro + 0x08) ofs_effects
        READ_SHORT (cur_ofs_pro + 0x0c) size_effects
        SET num_effects = 0
        FOR (cur_size = 0; cur_size < size_effects; cur_size += 264) BEGIN
          SET cur_ofs_fx = ofs_effects + cur_size
          READ_ASCII cur_ofs_fx $are(~projectile~ ~%idx_pro%~ ~effect~ ~%num_effects%~) (264)
          SET num_effects += 1
        END
        SET $are(~projectile~ ~%idx_pro%~ ~effect~) = num_effects
      END
    END
  END
END

/**
 * Used internally: Recreates the current ARE buffer by assembling the ARE array structure.
 *
 * STR_VAR are  Name of the ARE array structure. (Default: "are")
 */
DEFINE_PATCH_FUNCTION a7#__are_assemble
STR_VAR
  are = ~are~
RET
  success
BEGIN
  SET success = 1

  LPF a7#__are_validate INT_VAR quick = 0 STR_VAR are RET success END
  PATCH_IF (success) BEGIN
    LPF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END

    // Retrieving WED size and offset values
    LPF a7#__are_calculate_structure
      STR_VAR are
      RET
        size_total
        size_cre size_actor size_region size_spawnpoint size_entrance size_container size_item size_ambient
        size_variable size_door size_tiled size_vertex size_animation size_explored size_songs
        size_rest size_automap size_effect size_projectile
        offset_cre offset_actor offset_region offset_spawnpoint offset_entrance offset_container offset_item
        offset_ambient offset_variable offset_door offset_tiled offset_vertex offset_animation
        offset_explored offset_songs offset_rest offset_automap offset_effect offset_projectile
    END

    // removing old buffer content
    DELETE_BYTES 0 BUFFER_LENGTH

    // writing ARE data
    INSERT_BYTES 0 size_total

    SPRINT version $~%are%~(~version~)
    SET is_v1 = ~%version%~ STR_EQ ~V1.0~
    SET adjust = is_v1 ? 0 : 0x10

    // basic attributes and offsets
    WRITE_ASCIIE 0x00 ~AREA%version%~ (8)
    WRITE_ASCIIE 0x08 $~%are%~(~wed_resref~) (8)
    WRITE_LONG 0x10 $~%are%~(~last_saved~)
    WRITE_LONG 0x14 $~%are%~(~area_flags~)
    WRITE_ASCIIE 0x18 $~%are%~(~area_resref_north~) (8)
    WRITE_LONG 0x20 $~%are%~(~area_flags_north~)
    WRITE_ASCIIE 0x24 $~%are%~(~area_resref_east~) (8)
    WRITE_LONG 0x2c $~%are%~(~area_flags_east~)
    WRITE_ASCIIE 0x30 $~%are%~(~area_resref_south~) (8)
    WRITE_LONG 0x38 $~%are%~(~area_flags_south~)
    WRITE_ASCIIE 0x3c $~%are%~(~area_resref_west~) (8)
    WRITE_LONG 0x44 $~%are%~(~area_flags_west~)
    WRITE_SHORT 0x48 $~%are%~(~area_type~)
    WRITE_SHORT 0x4a $~%are%~(~probability_rain~)
    WRITE_SHORT 0x4c $~%are%~(~probability_snow~)
    WRITE_SHORT 0x4e $~%are%~(~probability_fog~)
    WRITE_SHORT 0x50 $~%are%~(~probability_lightning~)
    WRITE_BYTE 0x52 $~%are%~(~overlay_transparency~)
    WRITE_BYTE 0x53 0
    PATCH_IF (NOT is_v1) BEGIN
      WRITE_BYTE 0x54 $~%are%~(~area_difficulty_2~)
      WRITE_BYTE 0x55 $~%are%~(~area_difficulty_3~)
      WRITE_SHORT 0x56 $~%are%~(~area_difficulty_1~)
    END
    WRITE_ASCIIE (0x94 + adjust) $~%are%~(~area_script~) (8)
    PATCH_IF (is_v1) BEGIN
      WRITE_ASCIIE 0xd4 $~%are%~(~rest_movie_day~) (8)
      WRITE_ASCIIE 0xdc $~%are%~(~rest_movie_night~) (8)
    END

    // offsets and counts
    WRITE_LONG (0x54 + adjust) offset_actor
    WRITE_SHORT (0x58 + adjust) $~%are%~(~actor~)
    WRITE_SHORT (0x5a + adjust) $~%are%~(~region~)
    WRITE_LONG (0x5c + adjust) offset_region
    WRITE_LONG (0x60 + adjust) offset_spawnpoint
    WRITE_LONG (0x64 + adjust) $~%are%~(~spawnpoint~)
    WRITE_LONG (0x68 + adjust) offset_entrance
    WRITE_LONG (0x6c + adjust) $~%are%~(~entrance~)
    WRITE_LONG (0x70 + adjust) offset_container
    WRITE_SHORT (0x74 + adjust) $~%are%~(~container~)
    WRITE_SHORT (0x76 + adjust) (size_item / 20)
    WRITE_LONG (0x78 + adjust) offset_item
    WRITE_LONG (0x7c + adjust) offset_vertex
    WRITE_SHORT (0x80 + adjust) (size_vertex / 4)
    WRITE_SHORT (0x82 + adjust) $~%are%~(~ambient~)
    WRITE_LONG (0x84 + adjust) offset_ambient
    WRITE_LONG (0x88 + adjust) offset_variable
    WRITE_SHORT (0x8c + adjust) $~%are%~(~variable~)
    WRITE_SHORT (0x8e + adjust) 0 // # object flags (unused)
    WRITE_LONG (0x90 + adjust) 0  // object flags offset (unused)
    WRITE_LONG (0x9c + adjust) size_explored
    WRITE_LONG (0xa0 + adjust) offset_explored
    WRITE_LONG (0xa4 + adjust) $~%are%~(~door~)
    WRITE_LONG (0xa8 + adjust) offset_door
    WRITE_LONG (0xac + adjust) $~%are%~(~animation~)
    WRITE_LONG (0xb0 + adjust) offset_animation
    WRITE_LONG (0xb4 + adjust) $~%are%~(~tiled~)
    WRITE_LONG (0xb8 + adjust) offset_tiled
    WRITE_LONG (0xbc + adjust) offset_songs
    WRITE_LONG (0xc0 + adjust) offset_rest
    PATCH_IF (is_pst) BEGIN
      WRITE_LONG (0xc4 + adjust) "-1"
      WRITE_LONG (0xc8 + adjust) offset_automap
      WRITE_LONG (0xcc + adjust) $~%are%~(~automap~)
    END ELSE BEGIN
      WRITE_LONG (0xc4 + adjust) offset_automap
      WRITE_LONG (0xc8 + adjust) $~%are%~(~automap~)
      PATCH_IF (is_bg2 || is_ee) BEGIN
        SET count = $~%are%~(~projectile~)
        WRITE_LONG (0xcc + adjust) offset_projectile
        WRITE_LONG (0xd0 + adjust) count
      END ELSE BEGIN
        WRITE_LONG (0xcc + adjust) 0
        WRITE_LONG (0xd0 + adjust) 0
      END
    END

    SET item_index = 0    // index for container items
    SET vertex_index = 0  // index for polygon vertices

    // Actors
    SET num_actors = $~%are%~(~actor~)
    FOR (idx_actor = 0; idx_actor < num_actors; ++idx_actor) BEGIN
      // attached CRE
      SET cre_attached = $~%are%~(~actor~ ~%idx_actor%~ ~cre_attached~)
      PATCH_IF (cre_attached) BEGIN
        SPRINT buffer $~%are%~(~actor~ ~%idx_actor%~ ~cre~)
        SET cre_size = STRING_LENGTH ~%buffer%~
        WRITE_ASCIIE offset_cre ~%buffer%~ (cre_size)
      END ELSE BEGIN
        SET cre_size = 0
      END

      // actor
      SPRINT buffer $~%are%~(~actor~ ~%idx_actor%~)
      INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        PATCH_IF (cre_attached) BEGIN
          WRITE_LONG 0x88 offset_cre
          WRITE_LONG 0x8c cre_size
        END ELSE BEGIN
          WRITE_LONG 0x88 0
          WRITE_LONG 0x8c 0
        END
      END
      WRITE_ASCIIE offset_actor ~%buffer%~ (272)

      SET offset_cre += cre_size
      SET offset_actor += 272
    END

    // Regions
    SET num_regions = $~%are%~(~region~)
    FOR (idx_region = 0; idx_region < num_regions; ++idx_region) BEGIN
      // vertices
      SET num_vertices = $~%are%~(~region~ ~%idx_region%~ ~vertex~)
      FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
        SET value = $~%are%~(~region~ ~%idx_region%~ ~vertex~ ~%idx_vtx%~)
        SET ofs = offset_vertex + (vertex_index + idx_vtx) * 4
        WRITE_LONG ofs value
      END

      // region
      SPRINT buffer $~%are%~(~region~ ~%idx_region%~)
      INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        WRITE_LONG 0x2c vertex_index
      END
      WRITE_ASCIIE offset_region ~%buffer%~ (196)

      SET vertex_index += num_vertices
      SET offset_region += 196
    END

    // Spawn points
    SET num_spawns = $~%are%~(~spawnpoint~)
    FOR (idx_spawn = 0; idx_spawn < num_spawns; ++idx_spawn) BEGIN
      SPRINT buffer $~%are%~(~spawnpoint~ ~%idx_spawn%~)
      WRITE_ASCIIE offset_spawnpoint ~%buffer%~ (200)

      SET offset_spawnpoint += 200
    END

    // Entrances
    SET num_entrances = $~%are%~(~entrance~)
    FOR (idx_entrance = 0; idx_entrance < num_entrances; ++idx_entrance) BEGIN
      SPRINT buffer $~%are%~(~entrance~ ~%idx_entrance%~)
      WRITE_ASCIIE offset_entrance ~%buffer%~ (104)

      SET offset_entrance += 104
    END

    // Containers
    SET num_containers = $~%are%~(~container~)
    FOR (idx_container = 0; idx_container < num_containers; ++idx_container) BEGIN
      // items
      SET num_items = $~%are%~(~container~ ~%idx_container%~ ~item~)
      FOR (idx_item = 0; idx_item < num_items; ++idx_item) BEGIN
        SPRINT buffer $~%are%~(~container~ ~%idx_container%~ ~item~ ~%idx_item%~)
        SET ofs = offset_item + (item_index + idx_item) * 20
        WRITE_ASCIIE ofs ~%buffer%~ (20)
      END

      // vertices
      SET num_vertices = $~%are%~(~container~ ~%idx_container%~ ~vertex~)
      FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
        SET value = $~%are%~(~container~ ~%idx_container%~ ~vertex~ ~%idx_vtx%~)
        SET ofs = offset_vertex + (vertex_index + idx_vtx) * 4
        WRITE_LONG ofs value
      END

      SPRINT buffer $~%are%~(~container~ ~%idx_container%~)
      INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        WRITE_LONG 0x40 item_index
        WRITE_LONG 0x50 vertex_index
      END
      WRITE_ASCIIE offset_container ~%buffer%~ (192)

      SET item_index += num_items
      SET vertex_index += num_vertices
      SET offset_container += 192
    END

    // Ambients
    SET num_ambients = $~%are%~(~ambient~)
    FOR (idx_ambient = 0; idx_ambient < num_ambients; ++idx_ambient) BEGIN
      SPRINT buffer $~%are%~(~ambient~ ~%idx_ambient%~)
      WRITE_ASCIIE offset_ambient ~%buffer%~ (212)

      SET offset_ambient += 212
    END

    // Variables
    SET num_variables = $~%are%~(~variable~)
    FOR (idx_variable = 0; idx_variable < num_variables; ++idx_variable) BEGIN
      SPRINT buffer $~%are%~(~variable~ ~%idx_variable%~)
      WRITE_ASCIIE offset_variable ~%buffer%~ (84)

      SET offset_variable += 84
    END

    // Doors
    PATCH_DEFINE_ASSOCIATIVE_ARRAY door_keys BEGIN
      // array key    => "first index" field offset
      ~vertex_open~   => 0x2c
      ~vertex_closed~ => 0x34
      ~cell_open~    => 0x48
      ~cell_closed~  => 0x50
    END
    SET num_doors = $~%are%~(~door~)
    FOR (idx_door = 0; idx_door < num_doors; ++idx_door) BEGIN
      SPRINT buffer $~%are%~(~door~ ~%idx_door%~)

      // vertices and impeded cells
      PHP_EACH door_keys AS key => ofs_idx BEGIN
        SET num_vertices = $~%are%~(~door~ ~%idx_door%~ ~%key%~)
        FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
          SET value = $~%are%~(~door~ ~%idx_door%~ ~%key%~ ~%idx_vtx%~)
          SET ofs = offset_vertex + (vertex_index + idx_vtx) * 4
          WRITE_LONG ofs value
        END

        INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
          WRITE_LONG ofs_idx vertex_index
        END

        SET vertex_index += num_vertices
      END

      WRITE_ASCIIE offset_door ~%buffer%~ (200)

      SET offset_door += 200
    END

    // Tiled objects
    SET num_tiled = $~%are%~(~tiled~)
    FOR (idx_tiled = 0; idx_tiled < num_tiled; ++idx_tiled) BEGIN
      SPRINT buffer $~%are%~(~tiled~ ~%idx_tiled%~)

      // open search squares
      SET num_vertices = $~%are%~(~tiled~ ~%idx_tiled%~ ~cell_open~)
      FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
        SET value = $~%are%~(~tiled~ ~%idx_tiled%~ ~cell_open~ ~%idx_vtx%~)
        SET ofs = offset_vertex + (vertex_index + idx_vtx) * 4
        WRITE_LONG ofs value
      END
      INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        WRITE_LONG 0x2c vertex_index
      END
      SET vertex_index += num_vertices

      // closed search squares
      SET num_vertices = $~%are%~(~tiled~ ~%idx_tiled%~ ~cell_closed~)
      FOR (idx_vtx = 0; idx_vtx < num_vertices; ++idx_vtx) BEGIN
        SET value = $~%are%~(~tiled~ ~%idx_tiled%~ ~cell_closed~ ~%idx_vtx%~)
        SET ofs = offset_vertex + (vertex_index + idx_vtx) * 4
        WRITE_LONG ofs value
      END
      INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
        WRITE_LONG 0x34 vertex_index
      END
      SET vertex_index += num_vertices

      SET offset_tiled += 104
    END

    // Animations
    SET num_animations = $~%are%~(~animation~)
    FOR (idx_animation = 0; idx_animation < num_animations; ++idx_animation) BEGIN
      SPRINT buffer $~%are%~(~animation~ ~%idx_animation%~)
      WRITE_ASCIIE offset_animation ~%buffer%~ (76)

      SET offset_animation += 76
    END

    // Explored bitmap
    SPRINT buffer $~%are%~(~explored~)
    WRITE_ASCIIE offset_explored ~%buffer%~ (size_explored)

    // Songs
    SPRINT buffer $~%are%~(~songs~)
    WRITE_ASCIIE offset_songs ~%buffer%~ (size_songs)

    // Rest encounters
    SPRINT buffer $~%are%~(~rest~)
    WRITE_ASCIIE offset_rest ~%buffer%~ (size_rest)

    // Automap notes
    SET size_note = is_pst ? 532 : 52
    SET num_notes = $~%are%~(~automap~)
    FOR (idx_note = 0; idx_note < num_notes; ++idx_note) BEGIN
      SPRINT buffer $~%are%~(~automap~ ~%idx_note%~)
      WRITE_ASCIIE offset_automap ~%buffer%~ (size_note)

      SET offset_automap += size_note
    END

    // Projectile traps
    PATCH_IF (is_bg2 || is_ee) BEGIN
      SET eff_size = 264
      SET num_traps = $~%are%~(~projectile~)
      FOR (idx_trap = 0; idx_trap < num_traps; ++idx_trap) BEGIN
        SET num_eff = $~%are%~(~projectile~ ~%idx_trap%~ ~effect~)

        SPRINT buffer $~%are%~(~projectile~ ~%idx_trap%~)
        INNER_PATCH_SAVE buffer ~%buffer%~ BEGIN
          WRITE_LONG 0x08 offset_effect
          WRITE_SHORT 0x0c (num_eff * eff_size)
        END
        WRITE_ASCIIE offset_projectile ~%buffer%~ (28)

        // projectile effects
        FOR (idx_eff = 0; idx_eff < num_eff; ++idx_eff) BEGIN
          SPRINT buffer $~%are%~(~projectile~ ~%idx_trap%~ ~effect~ ~%idx_eff%~)
          WRITE_ASCIIE offset_effect ~%buffer%~ (eff_size)
          SET offset_effect += eff_size
        END

        SET offset_projectile += 28
      END
    END
  END
END

/**
 * Used internally: Validates basic elements in the specified ARE array structure.
 *
 * INT_VAR quick  Whether to do only a quick check. (Default: 1)
 * STR_VAR are    Name of the ARE array structure. (Default: "are")
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_validate
INT_VAR
  quick = 1
STR_VAR
  are = ~are~
RET
  success
BEGIN
  OUTER_SET success = VARIABLE_IS_SET $~%are%~(~version~)
  ACTION_IF (success) BEGIN
    OUTER_SPRINT ver $~%are%~(~version~)
    OUTER_SET success = (~%ver%~ STR_EQ ~V1.0~ || ~%ver%~ STR_EQ ~V9.1~)
  END

  ACTION_FOR_EACH key IN ~actor~ ~region~ ~spawnpoint~ ~entrance~ ~container~
                         ~ambient~ ~variable~ ~door~ ~animation~ BEGIN
    OUTER_SET success = success && IS_AN_INT $~%are%~(~%key%~)
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking actors
    OUTER_SET count = $~%are%~(~actor~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~actor~ ~%idx%~ ~name~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~actor~ ~%idx%~ ~cre_attached~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking regions
    OUTER_SET count = $~%are%~(~region~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~region~ ~%idx%~ ~name~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~region~ ~%idx%~ ~vertex~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking spawn points
    OUTER_SET count = $~%are%~(~spawnpoint~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~spawnpoint~ ~%idx%~ ~name~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking entrances
    OUTER_SET count = $~%are%~(~entrance~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~entrance~ ~%idx%~ ~name~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking containers
    OUTER_SET count = $~%are%~(~container~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~container~ ~%idx%~ ~name~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~container~ ~%idx%~ ~item~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~container~ ~%idx%~ ~vertex~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking ambient sounds
    OUTER_SET count = $~%are%~(~ambient~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~ambient~ ~%idx%~ ~name~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking variables
    OUTER_SET count = $~%are%~(~variable~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~variable~ ~%idx%~ ~name~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~variable~ ~%idx%~ ~value~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking doors
    OUTER_SET count = $~%are%~(~door~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~door~ ~%idx%~ ~name~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~door~ ~%idx%~ ~vertex_open~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~door~ ~%idx%~ ~vertex_closed~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~door~ ~%idx%~ ~cell_open~)
      OUTER_SET success = success && IS_AN_INT $~%are%~(~door~ ~%idx%~ ~cell_closed~)
    END
  END

  ACTION_IF (NOT quick && success) BEGIN
    // checking animations
    OUTER_SET count = $~%are%~(~animation~)
    OUTER_FOR (idx = 0; success && idx < count; ++idx) BEGIN
      OUTER_SET success = success && VARIABLE_IS_SET $~%are%~(~animation~ ~%idx%~ ~name~)
    END
  END
END

/**
 * Used internally: Validates the number of array elements.
 *
 * INT_VAR count  Min. number of expected array elements. Specify negative value to ignore expected result. (Default: -1)
 * STR_VAR name   Name of the array.
 * RET result     Determined number of array elements.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_validate_array
INT_VAR
  count = "-1"
STR_VAR
  name = ~~
RET
  result
BEGIN
  OUTER_FOR (result = 0; (count < 0 || result < count) && VARIABLE_IS_SET $~%name%~(~%result%~); ++result) BEGIN END
END

/**
 * Used internally: Determines the bounding box for a given array of vertex definitions.
 *
 * INT_VAR count    Number of vertex definitions in the array.
 * STR_VAR array    Name of the array with vertex definitions.
 * RET min_x        Minimum x coordinate.
 * RET max_x        Maximum x coordinate.
 * RET min_y        Minimum y coordinate.
 * RET max_y        Maximum y coordinate.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_calculate_poly_bounding_box
INT_VAR
  count = 0
STR_VAR
  array = ~~
RET
  min_x
  max_x
  min_y
  max_y
BEGIN
  OUTER_SET min_x = 0x7fff
  OUTER_SET max_x = 0
  OUTER_SET min_y = 0x7fff
  OUTER_SET max_y = 0

  ACTION_IF (NOT ~%array%~ STR_EQ ~~) BEGIN
    OUTER_FOR (i = 0; i < count; ++i) BEGIN
      ACTION_IF (IS_AN_INT $~%array%~(~%i%~)) BEGIN
        OUTER_SET value = $~%array%~(~%i%~)
        OUTER_SET x = (value BLSL 16) BASR 16
        OUTER_SET y = value BASR 16
        OUTER_SET min_x = (x < min_x) ? x : min_x
        OUTER_SET max_x = (x > max_x) ? x : max_x
        OUTER_SET min_y = (y < min_y) ? y : min_y
        OUTER_SET max_y = (y > max_y) ? y : max_y
      END
    END
  END

  OUTER_SET min_x = (min_x == 0x7fff) ? "-1" : min_x
  OUTER_SET min_y = (min_y == 0x7fff) ? "-1" : min_y
END

/**
 * Used internally: Checks whether the specified structure index exists, based on the specified parameters.
 *
 * INT_VAR index        Index of the ARE structure to patch. Omit if you specify the ARE structure by name.
 * INT_VAR silent       Specify 1 to suppress any feedback messages. (Default: 0)
 * STR_VAR are          Name of the ARE handle that is returned by "a7#are_open" and other batch functions.
 * STR_VAR type         Key name of the ARE structure type.
 * STR_VAR struct_name  Name of the ARE structure to patch. Omit if you specify the ARE structure by index.
 * STR_VAR field_name   Name of the array field that contains the string to compare. (Default: "name")
 * RET success          Returns 1 if the operation was successful, 0 otherwise.
 * RET index            Verified structure index if the function returns successfully.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_get_struct_index
INT_VAR
  index = "-1"
  silent = 0
STR_VAR
  are = ~are~
  type = ~~
  struct_name = ~~
  field_name = ~name~
RET
  success
  index
BEGIN
  OUTER_SET success = NOT ~%are%~ STR_EQ ~~
  OUTER_SET success = success && NOT ~%type%~ STR_EQ ~~ 
  OUTER_SET success = success && IS_AN_INT $~%are%~(~%type%~)
  OUTER_SET num_items = success ? $~%are%~(~%type%~) : 0

  ACTION_IF (success && STRING_LENGTH ~%struct_name%~ > 32) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: "%type%" name must not exceed 32 characters.~
    END
  END

  // determining structure index
  ACTION_IF (success) BEGIN
    ACTION_IF (NOT ~%struct_name%~ STR_EQ ~~) BEGIN
      // by name
      OUTER_SET index = "-1"
      OUTER_FOR (idx = 0; idx < num_items; ++idx) BEGIN
        ACTION_IF (VARIABLE_IS_SET $~%are%~(~%type%~ ~%idx%~ ~%field_name%~)) BEGIN
          OUTER_SPRINT name $~%are%~(~%type%~ ~%idx%~ ~%field_name%~)
          ACTION_IF (~%name%~ STR_EQ ~%struct_name%~) BEGIN
            OUTER_SET index = idx
            OUTER_SET idx = num_items
          END
        END
      END

      ACTION_IF (index < 0) BEGIN
        OUTER_SET success = 0
        ACTION_IF (NOT silent) BEGIN
          WARN ~WARNING: "%type%" not found with the specified %field_name%: %struct_name%~
        END
      END
    END
  END

  ACTION_IF (success && (index < 0 || index >= num_items)) BEGIN
    OUTER_SET success = 0
    ACTION_IF (NOT silent) BEGIN
      WARN ~WARNING: Index of "%type%" is out of bounds: %index%~
    END
  END
END

/**
 * Used internally: Calculates and returns ARE structure information (size and offset values) based on the specified are array structure.
 *
 * STR_VAR are              Name of the "are" array.
 * RET size_total           Total size of the whole ARE buffer.
 */
DEFINE_DIMORPHIC_FUNCTION a7#__are_calculate_structure
STR_VAR
  are = ~are~
RET
  size_total
  size_cre
  size_actor
  size_region
  size_spawnpoint
  size_entrance
  size_container
  size_item
  size_ambient
  size_variable
  size_door
  size_tiled
  size_vertex
  size_animation
  size_explored
  size_songs
  size_rest
  size_automap
  size_effect
  size_projectile
  offset_cre
  offset_actor
  offset_region
  offset_spawnpoint
  offset_entrance
  offset_container
  offset_item
  offset_ambient
  offset_variable
  offset_door
  offset_tiled
  offset_vertex
  offset_animation
  offset_explored
  offset_songs
  offset_rest
  offset_automap
  offset_effect
  offset_projectile
BEGIN
  LAF a7#__are_get_engine RET is_bg is_bg2 is_iwd is_iwd2 is_pst is_ee is_pstee END

  OUTER_SET is_v1 = $~%are%~(~version~) STR_EQ ~V1.0~
  OUTER_SET adjust = is_v1 ? 0 : 0x10

  OUTER_SET size_base = 0x11c + adjust
  OUTER_SET size_cre = 0
  OUTER_SET size_actor = 0
  OUTER_SET size_region = 0
  OUTER_SET size_spawnpoint = 0
  OUTER_SET size_entrance = 0
  OUTER_SET size_container = 0
  OUTER_SET size_item = 0
  OUTER_SET size_ambient = 0
  OUTER_SET size_variable = 0
  OUTER_SET size_door = 0
  OUTER_SET size_tiled = 0
  OUTER_SET size_vertex = 0
  OUTER_SET size_animation = 0
  OUTER_SET size_explored = STRING_LENGTH $~%are%~(~explored~)
  OUTER_SET size_songs = 144
  OUTER_SET size_rest = 228
  OUTER_SET size_automap = 0
  OUTER_SET size_effect = 0
  OUTER_SET size_projectile = 0

  // Actors
  OUTER_SET count = $~%are%~(~actor~)
  OUTER_SET size_actor = count * 272  // Actor size
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    ACTION_IF ($~%are%~(~actor~ ~%idx%~ ~cre_attached~)) BEGIN
      OUTER_SET size = STRING_LENGTH $~%are%~(~actor~ ~%idx%~ ~cre~) // attached CRE size
      OUTER_SET size_cre += size
    END
  END

  // Regions
  OUTER_SET count = $~%are%~(~region~)
  OUTER_SET size_region = count * 196 // Region size
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    OUTER_SET count2 = $~%are%~(~region~ ~%idx%~ ~vertex~)
    OUTER_SET size_vertex += count2 * 4 // Vertex size
  END

  // Spawn points
  OUTER_SET count = $~%are%~(~spawnpoint~)
  OUTER_SET size_spawnpoint = count * 200 // Spawn point size

  // Entrances
  OUTER_SET count = $~%are%~(~entrance~)
  OUTER_SET size_entrance = count * 104 // Entrance size

  // Containers
  OUTER_SET count = $~%are%~(~container~)
  OUTER_SET size_container = count * 192 // Container size
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    OUTER_SET count2 = $~%are%~(~container~ ~%idx%~ ~item~)
    OUTER_SET size_item += count2 * 20  // Item size
    OUTER_SET count2 = $~%are%~(~container~ ~%idx%~ ~vertex~)
    OUTER_SET size_vertex += count2 * 4 // Vertex size
  END

  // Ambient sounds
  OUTER_SET count = $~%are%~(~ambient~)
  OUTER_SET size_ambient = count * 212 // Ambient sound size

  // Variables
  OUTER_SET count = $~%are%~(~variable~)
  OUTER_SET size_variable = count * 84 // Variable size

  // Doors
  OUTER_SET count = $~%are%~(~door~)
  OUTER_SET size_door = count * 200 // Door size
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    OUTER_SET count2 = $~%are%~(~door~ ~%idx%~ ~vertex_open~)
    OUTER_SET size_vertex += count2 * 4 // Open vertex size
    OUTER_SET count2 = $~%are%~(~door~ ~%idx%~ ~vertex_closed~)
    OUTER_SET size_vertex += count2 * 4 // Closed vertex size
    OUTER_SET count2 = $~%are%~(~door~ ~%idx%~ ~cell_open~)
    OUTER_SET size_vertex += count2 * 4 // Impeded cell size
    OUTER_SET count2 = $~%are%~(~door~ ~%idx%~ ~cell_closed~)
    OUTER_SET size_vertex += count2 * 4 // Impeded cell size
  END
  
  // Tiled objects
  OUTER_SET count = $~%are%~(~tiled~)
  OUTER_SET size_tiled = count * 104  // Tiled object size
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    OUTER_SET count2 = $~%are%~(~tiled~ ~%idx%~ ~cell_open~)
    OUTER_SET size_vertex += count2 * 4  // Search cell size
    OUTER_SET count2 = $~%are%~(~tiled~ ~%idx%~ ~cell_closed~)
    OUTER_SET size_vertex += count2 * 4  // Search cell size
  END

  // Animations
  OUTER_SET count = $~%are%~(~animation~)
  OUTER_SET size_animation = count * 76

  // Automap notes
  OUTER_SET count = $~%are%~(~automap~)
  OUTER_SET size_note = is_pst ? 532 : 52
  OUTER_SET size_automap = count * size_note  // Automap note size

  // Projectile traps
  OUTER_SET count = $~%are%~(~projectile~)
  OUTER_SET size_projectile = count * 28  // Projectile trap size
  OUTER_FOR (idx = 0; idx < count; ++idx) BEGIN
    OUTER_SET count2 = $~%are%~(~projectile~ ~%idx%~ ~effect~)
    OUTER_SET size_effect += count2 * 264 // Effect size
  END

  // calculating offsets
  OUTER_SET offset_cre = size_base
  OUTER_SET offset_actor = offset_cre + size_cre
  OUTER_SET offset_region = offset_actor + size_actor
  OUTER_SET offset_spawnpoint = offset_region + size_region
  OUTER_SET offset_entrance = offset_spawnpoint + size_spawnpoint
  OUTER_SET offset_container = offset_entrance + size_entrance
  OUTER_SET offset_item = offset_container + size_container
  OUTER_SET offset_ambient = offset_item + size_item
  OUTER_SET offset_variable = offset_ambient + size_ambient
  OUTER_SET offset_door = offset_variable + size_variable
  OUTER_SET offset_tiled = offset_door + size_door
  OUTER_SET offset_vertex = offset_tiled + size_tiled
  OUTER_SET offset_animation = offset_vertex + size_vertex
  OUTER_SET offset_explored = offset_animation + size_animation
  OUTER_SET offset_songs = offset_explored + size_explored
  OUTER_SET offset_rest = offset_songs + size_songs
  OUTER_SET offset_automap = offset_rest + size_rest
  OUTER_SET offset_effect = offset_automap + size_automap
  OUTER_SET offset_projectile = offset_effect + size_effect

  OUTER_SET size_total = size_base
  OUTER_SET size_total += size_cre
  OUTER_SET size_total += size_actor
  OUTER_SET size_total += size_region
  OUTER_SET size_total += size_spawnpoint
  OUTER_SET size_total += size_entrance
  OUTER_SET size_total += size_container
  OUTER_SET size_total += size_item
  OUTER_SET size_total += size_ambient
  OUTER_SET size_total += size_variable
  OUTER_SET size_total += size_door
  OUTER_SET size_total += size_tiled
  OUTER_SET size_total += size_vertex
  OUTER_SET size_total += size_animation
  OUTER_SET size_total += size_explored
  OUTER_SET size_total += size_songs
  OUTER_SET size_total += size_rest
  OUTER_SET size_total += size_automap
  OUTER_SET size_total += size_effect
  OUTER_SET size_total += size_projectile
  // LOG ~DEBUG: size_total=%size_total%, size_cre=%size_cre%, size_actor=%size_actor%, size_region=%size_region%, size_spawnpoint=%size_spawnpoint%, size_entrance=%size_entrance%, size_container=%size_container%, size_item=%size_item%, size_ambient=%size_ambient%, size_variable=%size_variable%, size_door=%size_door%, size_tiled=%size_tiled%, size_vertex=%size_vertex%, size_animation=%size_animation%, size_explored=%size_explored%, size_songs=%size_songs%, size_rest=%size_rest%, size_automap=%size_automap%, size_effect=%size_effect%, size_projectile=%size_projectile%~
END
